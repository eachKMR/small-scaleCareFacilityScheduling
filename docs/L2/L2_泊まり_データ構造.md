# L2_泊まり_データ構造

**作成日**: 2025年11月23日  
**カテゴリ**: 第2層 - セクション別  
**バージョン**: 1.0

---

## 📖 このドキュメントについて

このドキュメントは、**泊まりセクションのデータ構造**を定義します。

### 対象読者

- 泊まりセクションの実装担当者
- データベース設計担当者
- テスト担当者

### 読了後に理解できること

- TomariReservation クラスの構造
- Room クラスの構造
- 期間管理の方法（入所日～退所日）
- バリデーションルール
- 型変換の責任分担
- 居室視点の表示方法（キャッシュ戦略）

---

## 1. データモデル概要

### 1.1 責務

**泊まりセクションが管理するデータ**:
- 居室ごとの宿泊予約
- 期間単位の管理（開始日～終了日）
- 定員管理（9人/日）
- 居室割当

### 1.2 設計方針：Single Source of Truth

```
データ：TomariReservationのみ（利用者視点）
  ↓
表示：ビューレイヤーで居室視点に変換
  ↓
高速化：キャッシュ戦略
```

**重要**: 居室視点のデータクラスは作らない（データの重複を避ける）

---

### 1.3 データの粒度

```
1レコード = 1人 × 1居室 × 1期間（開始日～終了日）
```

**例**:
```javascript
// 山田さんが1号室に11月20日～23日まで宿泊
{
  id: "tomari_001",
  userId: "user_yamada",
  roomId: "room01",
  startDate: "2025-11-20",
  endDate: "2025-11-23"
}
```

---

### 1.4 月別予定表との対応

```
月別予定表（横軸: 日付、縦軸: 居室）

        20日  21日  22日  23日  24日
1号室   入山  ○山  ○山  退山  空
2号室   ○内  ○内  ○内  ○内  ○内
3号室   ○木  退木  空    入花  ○花

入 = 入所（startDate）
○ = 宿泊継続中（startDate < date < endDate）
退 = 退所（endDate）
空 = 空室
```

**データとしての表現**:
```javascript
[
  { userId: "user_yamada", roomId: "room01", startDate: "2025-11-20", endDate: "2025-11-23" },
  { userId: "user_uchida", roomId: "room02", startDate: "2025-11-18", endDate: "2025-11-25" },
  { userId: "user_kimura", roomId: "room03", startDate: "2025-11-19", endDate: "2025-11-21" },
  { userId: "user_hanada", roomId: "room03", startDate: "2025-11-23", endDate: "2025-11-26" }
]
```

---

## 2. データ構造定義

### 2.1 Room クラス（居室マスタ）

#### プロパティ

| プロパティ名 | 型 | 必須 | デフォルト値 | 説明 |
|------------|----|----|----------|------|
| **id** | `string` | ✓ | - | 居室ID（例: `"room01"`） |
| **name** | `string` | ✓ | - | 居室名（例: `"1号室"`） |
| **isActive** | `boolean` | ✓ | `true` | 使用可/不可（メンテナンス中などで一時的に使えない） |
| **displayOrder** | `number` | - | `0` | 表示順序（グリッド表示時の並び順） |

---

#### 拡張性（Phase 2以降で追加可能）

```javascript
// Phase 2以降で追加可能な属性（AI連携用）
Room {
  id: "room01",
  name: "1号室",
  isActive: true,
  displayOrder: 1,
  
  // AI連携用の属性（後から追加）
  floor: 1,                     // 階数
  nearNurseStation: true,       // ナースステーションに近い
  equipment: ["介護ベッド"],    // 設備
  size: 10.5                    // 広さ（㎡）
}
```

**重要**: Phase 1では id, name, isActive, displayOrder のみ実装

---

#### Room クラスの実装例

```javascript
class Room {
  constructor(data) {
    this.id = data.id;
    this.name = data.name;
    this.isActive = data.isActive !== undefined ? data.isActive : true;
    this.displayOrder = data.displayOrder || 0;
  }

  validate() {
    if (!this.id) return { valid: false, error: '居室IDは必須です' };
    if (!this.name) return { valid: false, error: '居室名は必須です' };
    
    return { valid: true };
  }

  toJSON() {
    return {
      id: this.id,
      name: this.name,
      isActive: this.isActive,
      displayOrder: this.displayOrder
    };
  }

  static fromJSON(json) {
    return new Room(json);
  }
}
```

---

### 2.2 TomariReservation クラス

#### プロパティ

| プロパティ名 | 型 | 必須 | デフォルト値 | 説明 |
|------------|----|----|----------|------|
| **id** | `string` | ✓ | 自動生成 | 一意識別子（例: `"tomari_20251120_001"`） |
| **userId** | `string` | ✓ | - | 利用者ID（例: `"user001"`） |
| **roomId** | `string` | ✓ | - | 居室ID（例: `"room01"`） |
| **startDate** | `string` | ✓ | - | 入所日（`"YYYY-MM-DD"` 形式） |
| **endDate** | `string` | ✓ | - | 退所日（`"YYYY-MM-DD"` 形式） |
| **status** | `"計画"` \| `"実施"` \| `"中止"` | - | `"計画"` | 予定の状態（Phase 1では未使用） |
| **note** | `string` | - | `null` | メモ（例: `"体調確認"`） |
| **createdAt** | `string` | ✓ | 自動生成 | 作成日時（ISO形式） |
| **updatedAt** | `string` | ✓ | 自動生成 | 更新日時（ISO形式） |

---

#### ⚠️ 型に関する重要な注意

**日付は文字列（"YYYY-MM-DD"）を使用**

```javascript
✅ 正しい
const reservation = {
  startDate: "2025-11-20",
  endDate: "2025-11-23"
};

❌ 間違い
const reservation = {
  startDate: new Date("2025-11-20"),  // Date型は使わない
  endDate: new Date("2025-11-23")
};
```

**理由**:
- L1_技術_実装制約.md の「1.1 日付の扱い」に準拠
- HTMLの`data-date`属性との比較が容易
- タイムゾーンの問題を回避

---

#### IDの生成ルール

```javascript
// 形式: "tomari_" + 開始日 + "_" + 連番
id: "tomari_20251120_001"
```

**生成方法**:
```javascript
function generateTomariId(startDate) {
  const dateStr = startDate.replace(/-/g, ''); // "2025-11-20" → "20251120"
  const sequence = getNextSequence(); // 連番を取得
  return `tomari_${dateStr}_${sequence.toString().padStart(3, '0')}`;
}
```

---

#### startDate / endDate の意味

| 項目 | 意味 | 記号 |
|------|------|------|
| **startDate** | 入所日（宿泊開始） | "入" |
| **endDate** | 退所日（宿泊終了） | "退" |
| **中間日** | 宿泊継続中 | "○" |

**重要**: endDate は「退所する日」であり、「最後に泊まる日」ではない

**例**:
```javascript
// 11月20日に入所、23日に退所
{
  startDate: "2025-11-20",  // 20日の夜に泊まる
  endDate: "2025-11-23"     // 23日の朝にチェックアウト
}

// 実際の宿泊日数：3泊4日
// 20日夜、21日夜、22日夜 = 3泊
```

---

#### status（Phase 1では未使用）

| 値 | 意味 |
|----|----|
| `"計画"` | 予定（デフォルト） |
| `"実施"` | 実際に提供された |
| `"中止"` | キャンセル・中止 |

**Phase 1での扱い**:
- すべて`"計画"`として扱う
- Phase 2以降でCAREKARTEとの連携時に使用予定

---

### 2.3 TomariReservation クラスの実装例

```javascript
class TomariReservation {
  constructor(data) {
    this.id = data.id || this.#generateId(data.startDate);
    this.userId = data.userId;
    this.roomId = data.roomId;
    this.startDate = data.startDate;
    this.endDate = data.endDate;
    this.status = data.status || "計画";
    this.note = data.note || null;
    this.createdAt = data.createdAt || new Date().toISOString();
    this.updatedAt = data.updatedAt || new Date().toISOString();
  }

  #generateId(startDate) {
    const dateStr = startDate.replace(/-/g, '');
    const sequence = Math.floor(Math.random() * 1000); // 仮実装
    return `tomari_${dateStr}_${sequence.toString().padStart(3, '0')}`;
  }

  validate() {
    if (!this.userId) return { valid: false, error: '利用者IDは必須です' };
    if (!this.roomId) return { valid: false, error: '居室IDは必須です' };
    if (!this.startDate) return { valid: false, error: '入所日は必須です' };
    if (!this.endDate) return { valid: false, error: '退所日は必須です' };
    
    // 日付の形式チェック
    if (!this.isValidDate(this.startDate)) {
      return { valid: false, error: '入所日の形式が不正です' };
    }
    if (!this.isValidDate(this.endDate)) {
      return { valid: false, error: '退所日の形式が不正です' };
    }
    
    // 日付の前後関係チェック
    if (this.startDate >= this.endDate) {
      return { 
        valid: false, 
        error: '退所日は入所日より後である必要があります' 
      };
    }
    
    return { valid: true };
  }

  isValidDate(date) {
    // "YYYY-MM-DD" 形式のチェック
    const regex = /^\d{4}-\d{2}-\d{2}$/;
    if (!regex.test(date)) return false;
    
    // 実在する日付かチェック
    const d = new Date(date);
    return d instanceof Date && !isNaN(d.getTime());
  }

  // 期間内の日数を計算
  getDays() {
    const start = new Date(this.startDate);
    const end = new Date(this.endDate);
    const diffTime = end - start;
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    return diffDays + 1; // 開始日を含めるため+1
  }

  // 指定日が期間内かチェック
  includesDate(date) {
    return this.startDate <= date && date <= this.endDate;
  }

  // 指定日の状態を取得
  getStatusForDate(date) {
    if (!this.includesDate(date)) return null;
    
    if (date === this.startDate) return "入所";
    if (date === this.endDate) return "退所";
    return "継続";
  }

  toJSON() {
    return {
      id: this.id,
      userId: this.userId,
      roomId: this.roomId,
      startDate: this.startDate,
      endDate: this.endDate,
      status: this.status,
      note: this.note,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt
    };
  }

  static fromJSON(json) {
    return new TomariReservation(json);
  }
}
```

---

## 3. バリデーションルール

### 3.1 必須チェック

| プロパティ | チェック内容 |
|-----------|------------|
| **userId** | 必須、空文字列不可 |
| **roomId** | 必須、空文字列不可 |
| **startDate** | 必須、空文字列不可 |
| **endDate** | 必須、空文字列不可 |

---

### 3.2 形式チェック

#### 3.2.1 startDate / endDate（日付）

**形式**: `"YYYY-MM-DD"`

**チェック**:
```javascript
function isValidDate(date) {
  // 形式チェック
  const regex = /^\d{4}-\d{2}-\d{2}$/;
  if (!regex.test(date)) return false;
  
  // 実在する日付かチェック
  const d = new Date(date);
  return d instanceof Date && !isNaN(d.getTime());
}
```

---

#### 3.2.2 日付の前後関係

**ルール**: endDate は startDate より後

**チェック**:
```javascript
function validateDateRange(startDate, endDate) {
  if (startDate >= endDate) {
    return { 
      valid: false, 
      error: '退所日は入所日より後である必要があります' 
    };
  }
  
  // 期間が長すぎないかチェック（例: 30日以内）
  const start = new Date(startDate);
  const end = new Date(endDate);
  const diffDays = (end - start) / (1000 * 60 * 60 * 24);
  
  if (diffDays > 30) {
    return { 
      valid: false, 
      error: '宿泊期間は30日以内にしてください' 
    };
  }
  
  return { valid: true };
}
```

---

### 3.3 重複チェック

**ルール**: 同じ居室・同じ期間に2人以上の予約は不可

**チェック方法**:
```javascript
function checkRoomConflict(reservations, roomId, startDate, endDate, excludeId = null) {
  // 同じ居室の予約を抽出
  const roomReservations = reservations.filter(r => 
    r.roomId === roomId && r.id !== excludeId
  );
  
  // 期間が重複するかチェック
  const hasConflict = roomReservations.some(r => {
    // 期間の重複判定
    // A: |-------|
    // B:     |-------|
    // → 重複あり
    
    return !(r.endDate < startDate || endDate < r.startDate);
  });
  
  if (hasConflict) {
    return { 
      valid: false, 
      error: `${roomId}は指定期間に既に予約されています` 
    };
  }
  
  return { valid: true };
}
```

**期間重複の判定ロジック**:
```javascript
// 重複しない条件（どちらか）
// 1. A の終了日 < B の開始日
// 2. B の終了日 < A の開始日

// → 重複する条件（否定）
!(A.endDate < B.startDate || B.endDate < A.startDate)
```

---

### 3.4 定員チェック

**ルール**: 1日あたりの宿泊者数が9人以下

**チェック方法**:
```javascript
function checkCapacity(reservations, startDate, endDate) {
  // 指定期間の各日の宿泊者数をカウント
  const dates = getDateRange(startDate, endDate);
  
  for (const date of dates) {
    const count = reservations.filter(r => 
      r.startDate <= date && date <= r.endDate
    ).length;
    
    if (count >= 9) {
      return { 
        ok: false, 
        message: `${date}の定員（9人）に達しています（現在${count}人）` 
      };
    }
  }
  
  return { ok: true };
}

// 日付範囲を配列で取得
function getDateRange(startDate, endDate) {
  const dates = [];
  let current = new Date(startDate);
  const end = new Date(endDate);
  
  while (current <= end) {
    dates.push(current.toISOString().split('T')[0]);
    current.setDate(current.getDate() + 1);
  }
  
  return dates;
}
```

---

## 4. 型変換の責任

### 4.1 入力時の変換

#### 4.1.1 CSV/Excelからのインポート

**元データ**（泊まりの場合は期間情報が必要）:
```csv
利用者ID,居室ID,入所日,退所日
user001,room01,2025-11-20,2025-11-23
user002,room02,2025-11-18,2025-11-25
```

**変換処理**:
```javascript
function convertFromCSV(csvRow) {
  return new TomariReservation({
    userId: csvRow.利用者ID,
    roomId: csvRow.居室ID,
    startDate: csvRow.入所日,
    endDate: csvRow.退所日
  });
}
```

---

#### 4.1.2 画面からの入力

**ユーザーアクション**: 期間選択（ドラッグ等）

```javascript
function handleRangeSelection(roomId, startDate, endDate, userId) {
  // 新しい予約を作成
  const reservation = new TomariReservation({
    userId: userId,
    roomId: roomId,
    startDate: startDate,
    endDate: endDate
  });
  
  // バリデーション
  const validation = reservation.validate();
  if (!validation.valid) {
    throw new Error(validation.error);
  }
  
  return reservation;
}
```

---

### 4.2 出力時の変換

#### 4.2.1 画面表示への変換（居室視点）

**データ → 記号**:

```javascript
function getSymbolForCell(reservations, roomId, date) {
  // その居室・その日の予約を検索
  const reservation = reservations.find(r => 
    r.roomId === roomId &&
    r.startDate <= date &&
    date <= r.endDate
  );
  
  if (!reservation) return ""; // 空室
  
  // 状態に応じた記号を返す
  if (date === reservation.startDate) return "入";
  if (date === reservation.endDate) return "退";
  return "○";
}
```

**利用者名の表示**:
```javascript
function getUserNameForCell(reservations, users, roomId, date) {
  const reservation = reservations.find(r => 
    r.roomId === roomId &&
    r.startDate <= date &&
    date <= r.endDate
  );
  
  if (!reservation) return "";
  
  const user = users.find(u => u.userId === reservation.userId);
  return user ? user.name : "";
}
```

---

#### 4.2.2 CSV/Excelへのエクスポート

**データ → CSV**:
```javascript
function exportToCSV(reservations) {
  const rows = reservations.map(r => ({
    利用者ID: r.userId,
    居室ID: r.roomId,
    入所日: r.startDate,
    退所日: r.endDate,
    宿泊日数: r.getDays()
  }));
  
  return convertToCSV(rows);
}
```

---

#### 4.2.3 localStorageへの保存

**データ → JSON**:
```javascript
function saveToStorage(reservations) {
  const data = {
    version: '1.0',
    timestamp: new Date().toISOString(),
    reservations: reservations.map(r => r.toJSON())
  };
  
  localStorage.setItem(
    'projectB:tomari:reservations',
    JSON.stringify(data)
  );
}
```

**JSON → データ**:
```javascript
function loadFromStorage() {
  try {
    const json = localStorage.getItem('projectB:tomari:reservations');
    if (!json) return [];
    
    const data = JSON.parse(json);
    return data.reservations.map(r => TomariReservation.fromJSON(r));
  } catch (error) {
    console.error('データ読み込みエラー:', error);
    return [];
  }
}
```

---

## 5. 居室視点の表示（キャッシュ戦略）

### 5.1 設計方針

```
データ：TomariReservation（利用者視点）のみ
  ↓
表示：ビューレイヤーで居室視点に変換
  ↓
高速化：キャッシュで計算結果を保存
```

**重要**: 居室視点のデータクラスは作らない（Single Source of Truth）

---

### 5.2 キャッシュ戦略の実装

```javascript
class TomariSection {
  #reservations = [];
  #occupancyCache = new Map();  // key: "roomId_date", value: { userId, status, userName }
  
  /**
   * 居室視点で取得（キャッシュあり）
   * @param {string} roomId - 居室ID
   * @param {string} date - 日付（"YYYY-MM-DD"）
   * @returns {Object|null} { userId, status, userName } or null（空室）
   */
  getRoomOccupancy(roomId, date) {
    const key = `${roomId}_${date}`;
    
    // キャッシュにあれば返す
    if (this.#occupancyCache.has(key)) {
      return this.#occupancyCache.get(key);
    }
    
    // 計算
    const reservation = this.#reservations.find(r => 
      r.roomId === roomId &&
      r.startDate <= date &&
      date <= r.endDate
    );
    
    let result;
    if (!reservation) {
      result = null;  // 空室
    } else {
      const user = this.getUserById(reservation.userId);
      const status = reservation.getStatusForDate(date);
      
      result = {
        userId: reservation.userId,
        userName: user ? user.name : "",
        status: status  // "入所" | "継続" | "退所"
      };
    }
    
    // キャッシュに保存
    this.#occupancyCache.set(key, result);
    
    return result;
  }
  
  /**
   * キャッシュを無効化（予約追加・削除・更新時に呼ぶ）
   * @param {TomariReservation} reservation - 対象の予約
   */
  invalidateCache(reservation) {
    // この予約に関連する日付のキャッシュを削除
    const dates = this.getDateRange(reservation.startDate, reservation.endDate);
    
    dates.forEach(date => {
      this.#occupancyCache.delete(`${reservation.roomId}_${date}`);
    });
  }
  
  /**
   * すべてのキャッシュを無効化
   */
  invalidateAllCache() {
    this.#occupancyCache.clear();
  }
  
  /**
   * 予約追加
   */
  addReservation(reservation) {
    this.#reservations.push(reservation);
    this.invalidateCache(reservation);  // キャッシュを無効化
  }
  
  /**
   * 予約削除
   */
  removeReservation(reservationId) {
    const index = this.#reservations.findIndex(r => r.id === reservationId);
    if (index === -1) return { success: false, error: '予約が見つかりません' };
    
    const removed = this.#reservations[index];
    this.#reservations.splice(index, 1);
    this.invalidateCache(removed);  // キャッシュを無効化
    
    return { success: true };
  }
  
  // ユーティリティ関数
  getDateRange(startDate, endDate) {
    const dates = [];
    let current = new Date(startDate);
    const end = new Date(endDate);
    
    while (current <= end) {
      dates.push(current.toISOString().split('T')[0]);
      current.setDate(current.getDate() + 1);
    }
    
    return dates;
  }
  
  getUserById(userId) {
    // Phase 1では簡略化
    return { userId: userId, name: userId };
  }
}
```

---

### 5.3 キャッシュのライフサイクル

```
1. 初期状態: キャッシュは空
   ↓
2. 表示時: getRoomOccupancy() で計算＋キャッシュに保存
   ↓
3. 予約追加・削除・更新: invalidateCache() でキャッシュを削除
   ↓
4. 次回表示時: 再計算＋キャッシュに保存
```

**重要**: 予約を追加・削除・更新したら、必ずキャッシュを無効化する

---

## 6. データ操作の例

### 6.1 予約の追加

```javascript
function addReservation(reservations, userId, roomId, startDate, endDate) {
  // バリデーション
  const newReservation = new TomariReservation({ userId, roomId, startDate, endDate });
  const validation = newReservation.validate();
  if (!validation.valid) {
    throw new Error(validation.error);
  }
  
  // 居室の重複チェック
  const conflict = checkRoomConflict(reservations, roomId, startDate, endDate);
  if (!conflict.valid) {
    throw new Error(conflict.error);
  }
  
  // 定員チェック
  const capacity = checkCapacity(reservations, startDate, endDate);
  if (!capacity.ok) {
    throw new Error(capacity.message);
  }
  
  // 追加
  reservations.push(newReservation);
  return newReservation;
}
```

---

### 6.2 予約の削除

```javascript
function removeReservation(reservations, reservationId) {
  const index = reservations.findIndex(r => r.id === reservationId);
  
  if (index === -1) {
    throw new Error('予約が見つかりません');
  }
  
  reservations.splice(index, 1);
}
```

---

### 6.3 予約の変更

```javascript
function updateReservation(reservations, reservationId, updates) {
  const reservation = reservations.find(r => r.id === reservationId);
  if (!reservation) {
    throw new Error('予約が見つかりません');
  }
  
  // 更新
  Object.assign(reservation, updates);
  reservation.updatedAt = new Date().toISOString();
  
  // バリデーション
  const validation = reservation.validate();
  if (!validation.valid) {
    throw new Error(validation.error);
  }
  
  return reservation;
}
```

---

## 7. まとめ

### 7.1 このドキュメントで定義したこと

```
✅ 定義したこと
├─ Room クラスの構造（居室マスタ）
├─ TomariReservation クラスの構造（予約データ）
├─ プロパティの型・必須・デフォルト値
├─ バリデーションルール（必須、形式、重複、定員）
├─ 型変換の責任（入力時、出力時）
├─ 居室視点の表示方法（キャッシュ戦略）
└─ データ操作の例（追加、削除、変更）
```

---

### 7.2 重要なポイント

1. **日付は文字列**（"YYYY-MM-DD"）
2. **期間管理**（startDate～endDate）
3. **Single Source of Truth**（TomariReservationのみ）
4. **居室視点はキャッシュで高速化**
5. **定員は9人/日**
6. **期間重複チェックが重要**

---

### 7.3 次のステップ

このデータ構造に基づいて、UI設計とロジック設計を行います：

1. **L2_泊まり_UI設計.md** - 居室軸グリッド表示、期間選択
2. **L2_泊まり_ロジック.md** - 定員チェック、期間重複チェック

---

## 📚 次に読むべきドキュメント

このドキュメントを読了したら、以下のドキュメントに進んでください。

### 次のドキュメント

**L2_泊まり_UI設計.md**
- 居室軸の月別予定表
- 期間選択（ドラッグ等）
- 記号（入・○・退）の表示ルール

---

## 📝 参考資料

- L1_技術_実装制約.md（データ型規約）
- L0_業務_定員の法的枠組み.md（泊まり定員9人の根拠）
- L0_業務_居室管理の重要性.md（夜勤1人体制、居室管理）
- L2_通い_データ構造.md（通いセクションとの対比）

---

## 📅 更新履歴

| 日付 | バージョン | 変更内容 | 担当 |
|------|----------|---------|------|
| 2025-11-23 | 1.0 | 初版作成 | Claude |

---

**最終更新**: 2025年11月23日  
**次回更新予定**: Phase 1実装中のフィードバック反映時

---

## ⚠️ 設計チェックリスト

このドキュメントの品質チェック：

- [x] すべてのプロパティの型が明記されている
- [x] Date型と文字列の使い分けが明確
- [x] 型変換の責任が明確（どこで変換するか）
- [x] null/undefinedの扱いが定義されている
- [x] バリデーションルールが網羅されている

---

**このドキュメントを読了したら、INDEX_ドキュメント構成.md に戻り、次のドキュメントに進んでください。**