# L2_訪問_ロジック設計

**作成日**: 2025年11月23日  
**カテゴリ**: 第2層 - セクション別  
**バージョン**: 1.0

---

## 📖 このドキュメントについて

このドキュメントは、**訪問セクションのロジック設計**を定義します。

### 対象読者

- 訪問セクションの実装担当者
- テスト担当者
- コードレビュアー

### 読了後に理解できること

- 訪問予定の追加・編集・削除のアルゴリズム
- バリデーション処理の詳細
- 移動時間を考慮した検証
- イベント処理の順序と責任分担
- エラーハンドリング

### 設計の前提

- **L2_訪問_データ構造.md** の HoumonSchedule クラスに基づく
- **L2_訪問_UI設計.md** の UIインタラクションに基づく

---

## 1. クラス設計

### 1.1 HoumonSection クラス

#### 責務

```
HoumonSection = 訪問セクション全体の管理者

責務:
├─ 訪問予定の追加・編集・削除
├─ バリデーション
├─ 移動時間マトリックスとの連携
├─ イベント発火
└─ データの永続化
```

#### プロパティ

| プロパティ名 | 型 | 説明 |
|------------|----|----|
| **schedules** | `HoumonSchedule[]` | 訪問予定のリスト |
| **travelTimeMatrix** | `Object` | 移動時間マトリックス（共通データ） |
| **userMaster** | `Object` | 利用者マスタ（共通データ） |
| **staffMaster** | `Object` | 職員マスタ（共通データ） |

---

#### メソッド

| メソッド名 | 引数 | 戻り値 | 説明 |
|-----------|------|--------|------|
| **addSchedule** | `userId, date, timeMode, options` | `{ success, schedule?, errors? }` | 訪問予定を追加 |
| **updateSchedule** | `scheduleId, updates` | `{ success, schedule?, errors? }` | 訪問予定を更新 |
| **deleteSchedule** | `scheduleId` | `{ success }` | 訪問予定を削除 |
| **getSchedulesForDate** | `date` | `HoumonSchedule[]` | 特定日の訪問予定を取得 |
| **getSchedulesForUser** | `userId, date` | `HoumonSchedule[]` | 特定利用者・特定日の訪問予定を取得 |
| **validateSchedule** | `schedule` | `{ valid, errors? }` | 訪問予定のバリデーション |
| **checkTimeConflict** | `schedule` | `{ hasConflict, message? }` | 時間帯の重複チェック |
| **checkTravelTime** | `date` | `{ warnings[] }` | 移動時間の妥当性チェック |
| **sortSchedules** | `schedules` | `HoumonSchedule[]` | 訪問予定を時間順にソート |

---

### 1.2 実装例

```javascript
class HoumonSection {
  constructor(travelTimeMatrix, userMaster, staffMaster) {
    this.schedules = [];
    this.travelTimeMatrix = travelTimeMatrix;
    this.userMaster = userMaster;
    this.staffMaster = staffMaster;
  }
  
  /**
   * 訪問予定を追加
   */
  addSchedule(userId, date, timeMode, options = {}) {
    // 1. バリデーション
    const newSchedule = new HoumonSchedule({
      userId,
      date,
      timeMode,
      startTime: options.startTime || null,
      endTime: options.endTime || null,
      duration: options.duration || 30,
      staffId: options.staffId || null,
      note: options.note || ''
    });
    
    const validation = this.validateSchedule(newSchedule);
    if (!validation.valid) {
      return { success: false, errors: validation.errors };
    }
    
    // 2. 時間帯の重複チェック
    const conflict = this.checkTimeConflict(newSchedule);
    if (conflict.hasConflict) {
      return { 
        success: false, 
        errors: [conflict.message] 
      };
    }
    
    // 3. 追加
    this.schedules.push(newSchedule);
    
    // 4. イベント発火
    this.dispatchEvent('houmon:scheduleAdded', { schedule: newSchedule });
    
    // 5. 移動時間の警告チェック（追加後）
    const travelWarnings = this.checkTravelTime(date);
    if (travelWarnings.warnings.length > 0) {
      console.warn('移動時間の警告:', travelWarnings.warnings);
    }
    
    return { success: true, schedule: newSchedule };
  }
  
  /**
   * 訪問予定を更新
   */
  updateSchedule(scheduleId, updates) {
    // 1. 対象を検索
    const schedule = this.schedules.find(s => s.id === scheduleId);
    if (!schedule) {
      return { 
        success: false, 
        errors: ['訪問予定が見つかりません'] 
      };
    }
    
    // 2. 更新内容を適用
    Object.assign(schedule, updates);
    
    // 3. バリデーション
    const validation = this.validateSchedule(schedule);
    if (!validation.valid) {
      return { success: false, errors: validation.errors };
    }
    
    // 4. 時間帯の重複チェック
    const conflict = this.checkTimeConflict(schedule, scheduleId);
    if (conflict.hasConflict) {
      return { 
        success: false, 
        errors: [conflict.message] 
      };
    }
    
    // 5. イベント発火
    this.dispatchEvent('houmon:scheduleUpdated', { schedule });
    
    return { success: true, schedule };
  }
  
  /**
   * 訪問予定を削除
   */
  deleteSchedule(scheduleId) {
    const index = this.schedules.findIndex(s => s.id === scheduleId);
    if (index === -1) {
      return { 
        success: false, 
        errors: ['訪問予定が見つかりません'] 
      };
    }
    
    const deletedSchedule = this.schedules[index];
    this.schedules.splice(index, 1);
    
    this.dispatchEvent('houmon:scheduleDeleted', { 
      schedule: deletedSchedule 
    });
    
    return { success: true };
  }
  
  /**
   * 特定日の訪問予定を取得
   */
  getSchedulesForDate(date) {
    return this.schedules.filter(s => s.date === date);
  }
  
  /**
   * 特定利用者・特定日の訪問予定を取得
   */
  getSchedulesForUser(userId, date) {
    return this.schedules.filter(s => 
      s.userId === userId && s.date === date
    );
  }
  
  /**
   * 訪問予定のバリデーション
   */
  validateSchedule(schedule) {
    const errors = [];
    
    // 必須項目チェック
    if (!schedule.userId) {
      errors.push('利用者IDは必須です');
    }
    if (!schedule.date) {
      errors.push('日付は必須です');
    }
    if (!schedule.timeMode) {
      errors.push('時間帯は必須です');
    }
    
    // 利用者マスタの存在チェック
    if (schedule.userId && !this.userMaster[schedule.userId]) {
      errors.push(`利用者が見つかりません: ${schedule.userId}`);
    }
    
    // 職員マスタの存在チェック（指定されている場合）
    if (schedule.staffId && !this.staffMaster[schedule.staffId]) {
      errors.push(`職員が見つかりません: ${schedule.staffId}`);
    }
    
    // 厳守の場合の時刻チェック
    if (schedule.timeMode === 'strict') {
      if (!schedule.startTime) {
        errors.push('厳守の場合、開始時刻は必須です');
      }
      if (!schedule.endTime) {
        errors.push('厳守の場合、終了時刻は必須です');
      }
      if (schedule.startTime && schedule.endTime) {
        if (schedule.startTime >= schedule.endTime) {
          errors.push('終了時刻は開始時刻より後である必要があります');
        }
      }
    }
    
    // 所要時間チェック
    if (schedule.duration <= 0) {
      errors.push('所要時間は1分以上である必要があります');
    }
    if (schedule.duration > 180) {
      errors.push('所要時間は180分以下である必要があります');
    }
    
    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined
    };
  }
  
  /**
   * 時間帯の重複チェック
   */
  checkTimeConflict(newSchedule, excludeId = null) {
    const conflicts = this.schedules.filter(s => 
      s.id !== excludeId &&
      s.userId === newSchedule.userId &&
      s.date === newSchedule.date &&
      s.timeMode === newSchedule.timeMode
    );
    
    if (conflicts.length > 0) {
      const timeStr = newSchedule.getTimeDisplayString();
      return {
        hasConflict: true,
        message: `同じ時間帯（${timeStr}）に既に訪問予定があります`
      };
    }
    
    return { hasConflict: false };
  }
  
  /**
   * 移動時間の妥当性チェック
   */
  checkTravelTime(date) {
    const warnings = [];
    
    // その日の厳守訪問のみを対象
    const strictVisits = this.schedules
      .filter(s => s.date === date && s.timeMode === 'strict')
      .sort((a, b) => a.startTime.localeCompare(b.startTime));
    
    for (let i = 0; i < strictVisits.length - 1; i++) {
      const current = strictVisits[i];
      const next = strictVisits[i + 1];
      
      // 前の訪問の終了時刻
      const currentEnd = this.timeToMinutes(current.endTime);
      // 次の訪問の開始時刻
      const nextStart = this.timeToMinutes(next.startTime);
      // 利用可能な時間
      const availableTime = nextStart - currentEnd;
      
      // 必要な移動時間
      const travelTime = this.getTravelTime(current.userId, next.userId);
      
      if (availableTime < travelTime) {
        const currentUser = this.userMaster[current.userId];
        const nextUser = this.userMaster[next.userId];
        warnings.push({
          from: currentUser.name,
          to: nextUser.name,
          required: travelTime,
          available: availableTime,
          shortage: travelTime - availableTime
        });
      }
    }
    
    return { warnings };
  }
  
  /**
   * 移動時間を取得
   */
  getTravelTime(fromUserId, toUserId) {
    if (!this.travelTimeMatrix[fromUserId]) {
      return 20; // デフォルト
    }
    return this.travelTimeMatrix[fromUserId][toUserId] || 20;
  }
  
  /**
   * 時刻を分に変換
   */
  timeToMinutes(timeStr) {
    const [hours, minutes] = timeStr.split(':').map(Number);
    return hours * 60 + minutes;
  }
  
  /**
   * 訪問予定を時間順にソート
   */
  sortSchedules(schedules) {
    return schedules.sort((a, b) => {
      // 厳守同士の場合は時刻で比較
      if (a.timeMode === 'strict' && b.timeMode === 'strict') {
        return a.startTime.localeCompare(b.startTime);
      }
      
      // 時間帯の優先順位
      const timeModeOrder = {
        morning: 1,
        daytime: 2,
        afternoon: 3,
        evening: 4,
        night: 5,
        anytime: 6,
        strict: 0  // 厳守は最優先（実際の時刻順）
      };
      
      return timeModeOrder[a.timeMode] - timeModeOrder[b.timeMode];
    });
  }
  
  /**
   * イベント発火
   */
  dispatchEvent(eventName, detail) {
    const event = new CustomEvent(eventName, { detail });
    document.dispatchEvent(event);
  }
}
```

---

## 2. バリデーション処理

### 2.1 バリデーションの種類

| バリデーション | 実施タイミング | 失敗時の動作 |
|-------------|------------|-----------|
| **必須チェック** | 追加・編集時 | エラーメッセージ表示、保存不可 |
| **形式チェック** | 追加・編集時 | エラーメッセージ表示、保存不可 |
| **参照整合性チェック** | 追加・編集時 | エラーメッセージ表示、保存不可 |
| **時間帯重複チェック** | 追加・編集時 | エラーメッセージ表示、保存不可 |
| **移動時間チェック** | 追加・編集後 | 警告表示、保存は可能 |

---

### 2.2 バリデーションの詳細

#### 2.2.1 必須チェック

```javascript
function validateRequired(schedule) {
  const errors = [];
  
  if (!schedule.userId) {
    errors.push('利用者を選択してください');
  }
  
  if (!schedule.date) {
    errors.push('日付を入力してください');
  }
  
  if (!schedule.timeMode) {
    errors.push('時間帯を選択してください');
  }
  
  if (!schedule.duration || schedule.duration <= 0) {
    errors.push('所要時間を入力してください');
  }
  
  return errors;
}
```

---

#### 2.2.2 形式チェック

```javascript
function validateFormat(schedule) {
  const errors = [];
  
  // 日付形式
  if (schedule.date && !/^\d{4}-\d{2}-\d{2}$/.test(schedule.date)) {
    errors.push('日付の形式が不正です（YYYY-MM-DD）');
  }
  
  // 時刻形式（厳守の場合）
  if (schedule.timeMode === 'strict') {
    if (schedule.startTime && !/^([01]\d|2[0-3]):([0-5]\d)$/.test(schedule.startTime)) {
      errors.push('開始時刻の形式が不正です（HH:MM）');
    }
    if (schedule.endTime && !/^([01]\d|2[0-3]):([0-5]\d)$/.test(schedule.endTime)) {
      errors.push('終了時刻の形式が不正です（HH:MM）');
    }
  }
  
  // 所要時間
  if (schedule.duration > 180) {
    errors.push('所要時間は180分以内で入力してください');
  }
  
  return errors;
}
```

---

#### 2.2.3 論理チェック

```javascript
function validateLogic(schedule) {
  const errors = [];
  
  // 厳守の場合の時刻チェック
  if (schedule.timeMode === 'strict') {
    if (!schedule.startTime || !schedule.endTime) {
      errors.push('厳守の場合は開始時刻と終了時刻を入力してください');
    } else if (schedule.startTime >= schedule.endTime) {
      errors.push('終了時刻は開始時刻より後にしてください');
    }
  }
  
  return errors;
}
```

---

#### 2.2.4 参照整合性チェック

```javascript
function validateReferences(schedule, userMaster, staffMaster) {
  const errors = [];
  
  // 利用者マスタ
  if (schedule.userId && !userMaster[schedule.userId]) {
    errors.push(`利用者が見つかりません: ${schedule.userId}`);
  }
  
  // 職員マスタ（指定されている場合のみ）
  if (schedule.staffId && !staffMaster[schedule.staffId]) {
    errors.push(`職員が見つかりません: ${schedule.staffId}`);
  }
  
  return errors;
}
```

---

#### 2.2.5 時間帯重複チェック

```javascript
function checkTimeConflict(schedules, newSchedule, excludeId = null) {
  const conflicts = schedules.filter(s => 
    s.id !== excludeId &&
    s.userId === newSchedule.userId &&
    s.date === newSchedule.date &&
    s.timeMode === newSchedule.timeMode
  );
  
  if (conflicts.length > 0) {
    const timeStr = newSchedule.getTimeDisplayString();
    return {
      hasConflict: true,
      message: `同じ時間帯（${timeStr}）に既に訪問予定があります`
    };
  }
  
  return { hasConflict: false };
}
```

---

### 2.3 バリデーションの統合

```javascript
function validateScheduleFull(schedule, schedules, userMaster, staffMaster, excludeId = null) {
  const allErrors = [
    ...validateRequired(schedule),
    ...validateFormat(schedule),
    ...validateLogic(schedule),
    ...validateReferences(schedule, userMaster, staffMaster)
  ];
  
  // 時間帯重複チェック
  const conflict = checkTimeConflict(schedules, schedule, excludeId);
  if (conflict.hasConflict) {
    allErrors.push(conflict.message);
  }
  
  return {
    valid: allErrors.length === 0,
    errors: allErrors
  };
}
```

---

## 3. 移動時間の検証

### 3.1 移動時間チェックの目的

訪問スケジュールにおいて、**前の訪問から次の訪問への移動時間**が確保されているかを確認します。

**例**:
```
10:00-10:30 安藤さん宅訪問
10:40-11:00 田中さん宅訪問

→ 10分しか空いていないが、移動に15分必要
→ 警告を表示
```

---

### 3.2 移動時間チェックのアルゴリズム

```javascript
function checkTravelTime(schedules, date, travelTimeMatrix, userMaster) {
  const warnings = [];
  
  // その日の厳守訪問のみを対象
  const strictVisits = schedules
    .filter(s => s.date === date && s.timeMode === 'strict')
    .sort((a, b) => a.startTime.localeCompare(b.startTime));
  
  if (strictVisits.length < 2) {
    return { warnings }; // 1件以下なら問題なし
  }
  
  for (let i = 0; i < strictVisits.length - 1; i++) {
    const current = strictVisits[i];
    const next = strictVisits[i + 1];
    
    // 時刻を分単位に変換
    const currentEnd = timeToMinutes(current.endTime);
    const nextStart = timeToMinutes(next.startTime);
    
    // 利用可能な時間
    const availableTime = nextStart - currentEnd;
    
    // 必要な移動時間
    const travelTime = getTravelTime(
      travelTimeMatrix, 
      current.userId, 
      next.userId
    );
    
    // 不足している場合
    if (availableTime < travelTime) {
      const currentUser = userMaster[current.userId];
      const nextUser = userMaster[next.userId];
      
      warnings.push({
        type: 'travel_time_shortage',
        from: {
          userId: current.userId,
          userName: currentUser.name,
          endTime: current.endTime
        },
        to: {
          userId: next.userId,
          userName: nextUser.name,
          startTime: next.startTime
        },
        required: travelTime,
        available: availableTime,
        shortage: travelTime - availableTime
      });
    }
  }
  
  return { warnings };
}

function getTravelTime(matrix, fromUserId, toUserId) {
  if (!matrix[fromUserId]) {
    return 20; // デフォルト
  }
  return matrix[fromUserId][toUserId] || 20;
}

function timeToMinutes(timeStr) {
  const [hours, minutes] = timeStr.split(':').map(Number);
  return hours * 60 + minutes;
}
```

---

### 3.3 警告の表示

```javascript
// 警告を表示
function displayTravelWarnings(warnings) {
  if (warnings.length === 0) return;
  
  const messages = warnings.map(w => 
    `${w.from.userName}（${w.from.endTime}終了）から` +
    `${w.to.userName}（${w.to.startTime}開始）への移動時間が` +
    `${w.shortage}分不足しています（必要: ${w.required}分、実際: ${w.available}分）`
  );
  
  // トースト通知で表示
  showToast('移動時間の警告\n' + messages.join('\n'), 'warning');
  
  // または、モーダルで詳細表示
  showWarningModal('移動時間の警告', messages);
}
```

---

## 4. データ操作のフロー

### 4.1 訪問追加のフロー

```
┌─────────────────────────────────────┐
│ 1. ユーザー入力（モーダル）          │
└────────────┬────────────────────────┘
             │
             ↓
┌─────────────────────────────────────┐
│ 2. バリデーション                    │
│    - 必須チェック                    │
│    - 形式チェック                    │
│    - 論理チェック                    │
│    - 参照整合性チェック              │
└────────────┬────────────────────────┘
             │ OK
             ↓
┌─────────────────────────────────────┐
│ 3. 時間帯重複チェック                │
└────────────┬────────────────────────┘
             │ OK
             ↓
┌─────────────────────────────────────┐
│ 4. データ追加                        │
│    schedules.push(newSchedule)       │
└────────────┬────────────────────────┘
             │
             ↓
┌─────────────────────────────────────┐
│ 5. イベント発火                      │
│    'houmon:scheduleAdded'            │
└────────────┬────────────────────────┘
             │
             ↓
┌─────────────────────────────────────┐
│ 6. 移動時間チェック（警告のみ）      │
└────────────┬────────────────────────┘
             │
             ↓
┌─────────────────────────────────────┐
│ 7. UI更新                            │
│    - グリッド再描画                  │
│    - トースト表示                    │
└─────────────────────────────────────┘
```

---

### 4.2 訪問編集のフロー

```
┌─────────────────────────────────────┐
│ 1. ユーザー編集（モーダル）          │
└────────────┬────────────────────────┘
             │
             ↓
┌─────────────────────────────────────┐
│ 2. 対象の訪問予定を検索              │
└────────────┬────────────────────────┘
             │ 見つかった
             ↓
┌─────────────────────────────────────┐
│ 3. 更新内容を適用                    │
│    Object.assign(schedule, updates)  │
└────────────┬────────────────────────┘
             │
             ↓
┌─────────────────────────────────────┐
│ 4. バリデーション                    │
└────────────┬────────────────────────┘
             │ OK
             ↓
┌─────────────────────────────────────┐
│ 5. 時間帯重複チェック                │
│    （自分自身は除外）                │
└────────────┬────────────────────────┘
             │ OK
             ↓
┌─────────────────────────────────────┐
│ 6. イベント発火                      │
│    'houmon:scheduleUpdated'          │
└────────────┬────────────────────────┘
             │
             ↓
┌─────────────────────────────────────┐
│ 7. UI更新                            │
└─────────────────────────────────────┘
```

---

### 4.3 訪問削除のフロー

```
┌─────────────────────────────────────┐
│ 1. ユーザーが削除ボタンをクリック    │
└────────────┬────────────────────────┘
             │
             ↓
┌─────────────────────────────────────┐
│ 2. 確認ダイアログ                    │
│    「本当に削除しますか?」           │
└────────────┬────────────────────────┘
             │ はい
             ↓
┌─────────────────────────────────────┐
│ 3. データ削除                        │
│    schedules.splice(index, 1)        │
└────────────┬────────────────────────┘
             │
             ↓
┌─────────────────────────────────────┐
│ 4. イベント発火                      │
│    'houmon:scheduleDeleted'          │
└────────────┬────────────────────────┘
             │
             ↓
┌─────────────────────────────────────┐
│ 5. UI更新                            │
│    - グリッド再描画                  │
│    - トースト表示                    │
└─────────────────────────────────────┘
```

---

## 5. イベント駆動の設計

### 5.1 イベントの種類

| イベント名 | タイミング | payload | 用途 |
|-----------|----------|---------|------|
| **houmon:scheduleAdded** | 訪問追加時 | `{ schedule }` | UI更新、自動保存 |
| **houmon:scheduleUpdated** | 訪問更新時 | `{ schedule }` | UI更新、自動保存 |
| **houmon:scheduleDeleted** | 訪問削除時 | `{ schedule }` | UI更新、自動保存 |
| **houmon:validationError** | バリデーションエラー | `{ errors }` | エラー表示 |
| **houmon:travelWarning** | 移動時間警告 | `{ warnings }` | 警告表示 |

---

### 5.2 イベントリスナーの登録

```javascript
// 訪問追加時の処理
document.addEventListener('houmon:scheduleAdded', (event) => {
  const { schedule } = event.detail;
  
  console.log('訪問が追加されました:', schedule);
  
  // UI更新
  renderHoumonGrid();
  
  // 自動保存
  saveToLocalStorage();
  
  // トースト表示
  showToast('訪問を追加しました', 'success');
});

// 訪問更新時の処理
document.addEventListener('houmon:scheduleUpdated', (event) => {
  const { schedule } = event.detail;
  
  console.log('訪問が更新されました:', schedule);
  
  // UI更新
  renderHoumonGrid();
  
  // 自動保存
  saveToLocalStorage();
  
  // トースト表示
  showToast('訪問を更新しました', 'success');
});

// 訪問削除時の処理
document.addEventListener('houmon:scheduleDeleted', (event) => {
  const { schedule } = event.detail;
  
  console.log('訪問が削除されました:', schedule);
  
  // UI更新
  renderHoumonGrid();
  
  // 自動保存
  saveToLocalStorage();
  
  // トースト表示
  showToast('訪問を削除しました', 'info');
});

// 移動時間警告
document.addEventListener('houmon:travelWarning', (event) => {
  const { warnings } = event.detail;
  
  console.warn('移動時間の警告:', warnings);
  
  // 警告表示
  displayTravelWarnings(warnings);
});
```

---

### 5.3 イベント発火

```javascript
// HoumonSectionクラス内
dispatchEvent(eventName, detail) {
  const event = new CustomEvent(eventName, { 
    detail,
    bubbles: true,
    cancelable: false
  });
  document.dispatchEvent(event);
}

// 使用例
this.dispatchEvent('houmon:scheduleAdded', { 
  schedule: newSchedule 
});
```

---

## 6. エラーハンドリング

### 6.1 エラーの種類

| エラー種別 | 原因 | 対応 | 状態復旧 |
|-----------|------|------|----------|
| **ValidationError** | 入力値が不正 | エラーメッセージ表示、保存不可 | フォーム内容保持、入力欄にフォーカス |
| **ConflictError** | 時間帯重複 | エラーメッセージ表示、保存不可 | フォーム内容保持、該当項目をハイライト |
| **NotFoundError** | データが見つからない | エラーメッセージ表示 | モーダルを閉じる、グリッドを再描画 |
| **TravelWarning** | 移動時間不足 | 警告表示、保存は可能 | 通常の保存処理続行 |
| **ConcurrentEditError** | 同時編集 | 警告表示、最新データを再読み込み | フォームをリセット、最新データを表示 |

---

### 6.2 エラーメッセージの表示

```javascript
function showError(errors) {
  if (!errors || errors.length === 0) return;
  
  const message = errors.join('\n');
  
  // トースト通知
  showToast(message, 'error');
  
  // または、モーダル
  showErrorModal('エラー', errors);
}

function showErrorModal(title, errors) {
  const modal = document.createElement('div');
  modal.className = 'error-modal';
  modal.innerHTML = `
    <div class="modal-content">
      <h3>${title}</h3>
      <ul>
        ${errors.map(e => `<li>${e}</li>`).join('')}
      </ul>
      <button onclick="this.closest('.error-modal').remove()">閉じる</button>
    </div>
  `;
  document.body.appendChild(modal);
}
```

---

### 6.3 警告メッセージの表示

```javascript
function showWarning(warnings) {
  if (!warnings || warnings.length === 0) return;
  
  const messages = warnings.map(w => 
    `${w.from.userName}から${w.to.userName}への移動時間が${w.shortage}分不足`
  );
  
  showToast('⚠️ ' + messages.join('\n'), 'warning');
}
```

---

### 6.4 競合制御

#### 6.4.1 連続クリック防止

```javascript
let isProcessing = false;

async function handleSaveClick() {
  if (isProcessing) {
    console.log('処理中です。しばらくお待ちください。');
    return;
  }
  
  isProcessing = true;
  
  try {
    await saveVisit();
  } finally {
    isProcessing = false;
  }
}
```

#### 6.4.2 同時編集の検出（Phase 2以降）

```javascript
class HoumonSchedule {
  constructor(data) {
    // ...
    this.version = data.version || 1; // バージョン管理
    this.updatedAt = data.updatedAt || new Date().toISOString();
  }
}

function updateSchedule(scheduleId, updates) {
  const schedule = schedules.find(s => s.id === scheduleId);
  
  // バージョンチェック（Phase 2以降、サーバー連携時）
  if (updates.version && schedule.version !== updates.version) {
    return {
      success: false,
      error: 'ConcurrentEditError',
      message: 'データが他のユーザーによって更新されています。最新データを再読み込みしてください。'
    };
  }
  
  // 更新処理
  Object.assign(schedule, updates);
  schedule.version += 1;
  schedule.updatedAt = new Date().toISOString();
  
  return { success: true, schedule };
}
```

---

## 7. データ永続化

### 7.1 Phase 1（localStorage）

#### 保存

```javascript
function saveToLocalStorage(schedules, year, month) {
  const key = `houmon_schedules_${year}${month.toString().padStart(2, '0')}`;
  const data = {
    version: '1.0',
    savedAt: new Date().toISOString(),
    schedules: schedules.map(s => ({
      id: s.id,
      userId: s.userId,
      date: s.date,
      timeMode: s.timeMode,
      startTime: s.startTime,
      endTime: s.endTime,
      duration: s.duration,
      staffId: s.staffId,
      note: s.note
    }))
  };
  
  localStorage.setItem(key, JSON.stringify(data));
  console.log(`訪問予定を保存しました: ${key}`);
}
```

---

#### 読み込み

```javascript
function loadFromLocalStorage(year, month) {
  const key = `houmon_schedules_${year}${month.toString().padStart(2, '0')}`;
  const json = localStorage.getItem(key);
  
  if (!json) {
    console.log('保存されたデータがありません');
    return [];
  }
  
  try {
    const data = JSON.parse(json);
    console.log(`訪問予定を読み込みました: ${key} (${data.schedules.length}件)`);
    
    return data.schedules.map(s => new HoumonSchedule(s));
  } catch (error) {
    console.error('データ読み込みエラー:', error);
    return [];
  }
}
```

---

### 7.2 Phase 2（サーバー連携）

#### API設計

```
GET    /api/houmon/schedules?year=2025&month=11
POST   /api/houmon/schedules
PUT    /api/houmon/schedules/{id}
DELETE /api/houmon/schedules/{id}
```

#### リクエスト/レスポンス例

```javascript
// POST /api/houmon/schedules
// Request
{
  "userId": "user001",
  "date": "2025-11-25",
  "timeMode": "morning",
  "duration": 30,
  "staffId": "staff001"
}

// Response
{
  "success": true,
  "data": {
    "id": "houmon_20251125_001",
    "userId": "user001",
    "date": "2025-11-25",
    "timeMode": "morning",
    "startTime": null,
    "endTime": null,
    "duration": 30,
    "staffId": "staff001",
    "note": ""
  }
}
```

---

## 8. パフォーマンス最適化

### 8.1 キャッシュ戦略

**問題**: 毎回すべての訪問予定をフィルタリングすると遅い

**解決**: 日付別にキャッシュ

```javascript
class HoumonSection {
  constructor() {
    this.schedules = [];
    this.cache = new Map(); // 日付 → 訪問予定リスト
  }
  
  addSchedule(userId, date, timeMode, options) {
    // ... 追加処理
    
    // キャッシュを無効化
    this.cache.delete(date);
    
    return { success: true, schedule: newSchedule };
  }
  
  getSchedulesForDate(date) {
    // キャッシュがあれば返す
    if (this.cache.has(date)) {
      return this.cache.get(date);
    }
    
    // キャッシュがなければ計算
    const schedules = this.schedules.filter(s => s.date === date);
    this.cache.set(date, schedules);
    
    return schedules;
  }
}
```

---

### 8.2 差分更新

**問題**: グリッド全体を再描画すると重い

**解決**: 変更されたセルのみ更新

```javascript
function updateCell(userId, date) {
  const cell = document.querySelector(
    `.schedule-cell[data-user-id="${userId}"][data-date="${date}"]`
  );
  
  if (!cell) return;
  
  const schedules = houmonSection.getSchedulesForUser(userId, date);
  const sortedSchedules = houmonSection.sortSchedules(schedules);
  
  // セルの内容を更新
  const visitList = cell.querySelector('.visit-list');
  visitList.innerHTML = sortedSchedules.map(s => `
    <span class="visit-item ${s.timeMode}" data-visit-id="${s.id}">
      ${s.getTimeDisplayString()}
    </span>
  `).join('');
}
```

---

## 9. テストケース

### 9.1 正常系

| テストケース | 入力 | 期待される結果 |
|------------|------|--------------|
| **朝訪問の追加** | `timeMode: "morning"` | 追加成功、イベント発火 |
| **厳守訪問の追加** | `timeMode: "strict", startTime: "10:00", endTime: "10:30"` | 追加成功 |
| **訪問の編集** | `duration: 60` | 更新成功 |
| **訪問の削除** | `scheduleId` | 削除成功 |

---

### 9.2 異常系

| テストケース | 入力 | 期待されるエラー |
|------------|------|---------------|
| **利用者IDなし** | `userId: null` | "利用者を選択してください" |
| **厳守で時刻なし** | `timeMode: "strict", startTime: null` | "厳守の場合、開始時刻は必須です" |
| **時間帯重複** | 同じ利用者・日付・時間帯 | "同じ時間帯に既に訪問予定があります" |
| **存在しない職員** | `staffId: "invalid"` | "職員が見つかりません" |

---

### 9.3 境界値テスト

| テストケース | 入力 | 期待される結果 |
|------------|------|--------------|
| **所要時間1分** | `duration: 1` | 追加成功 |
| **所要時間180分** | `duration: 180` | 追加成功 |
| **所要時間181分** | `duration: 181` | エラー: "所要時間は180分以内で入力してください" |
| **所要時間0分** | `duration: 0` | エラー: "所要時間は1分以上である必要があります" |

---

## 10. まとめ

### 10.1 このドキュメントで定義したこと

```
✅ 定義したこと
├─ HoumonSection クラスの設計
├─ バリデーション処理（5種類）
├─ 移動時間の検証ロジック
├─ データ操作のフロー（追加・編集・削除）
├─ イベント駆動の設計
├─ エラーハンドリング
├─ データ永続化（localStorage、API）
└─ パフォーマンス最適化（キャッシュ、差分更新）
```

---

### 10.2 重要なポイント

1. **バリデーションは多段階**: 必須→形式→論理→参照整合性→重複
2. **移動時間チェックは警告のみ**: 保存は可能
3. **イベント駆動**: データ変更時にイベント発火→UI自動更新
4. **キャッシュで高速化**: 日付別にキャッシュ、変更時に無効化
5. **差分更新**: グリッド全体ではなく、変更セルのみ更新

---

### 10.3 Phase 1で実装すること

```
✅ Phase 1
├─ 訪問の追加・編集・削除
├─ バリデーション処理
├─ 時間帯重複チェック
├─ イベント駆動の基本実装
├─ localStorage による永続化
└─ エラーメッセージ表示

⏭️ Phase 2以降
├─ 移動時間チェックの詳細化
├─ 職員リソース管理
├─ サーバー連携（API）
├─ 訪問ルート最適化
└─ パフォーマンス最適化
```

---

## 📚 次に読むべきドキュメント

このドキュメントを読了したら、以下のドキュメントに進んでください。

### 関連ドキュメント

- **L2_訪問_データ構造.md** - データ構造の詳細
- **L2_訪問_UI設計.md** - UI設計の詳細
- **L1_データ_共通データ構造.md** - 移動時間マトリックスの定義
- **L3_UI_統合UI設計.md** - セクション間の連携

---

## 📝 参考資料

- L0_業務_調整業務の制約.md（訪問サービスの業務背景）
- L1_技術_実装制約.md（技術的制約）
- CHECKLIST_設計レビュー.md（レビュー項目）

---

## 📅 更新履歴

| 日付 | バージョン | 変更内容 | 担当 |
|------|----------|---------|------|
| 2025-11-23 | 1.0 | 初版作成 | Claude |

---

**最終更新**: 2025年11月23日  
**次回更新予定**: Phase 1実装中のフィードバック反映時

---

## ⚠️ 設計チェックリスト

このドキュメントの品質チェック：

- [x] すべてのメソッドのシグネチャが明記されている
- [x] バリデーションルールが網羅されている
- [x] エラーハンドリングが具体的に記述されている
- [x] イベント駆動の設計が明確
- [x] データフローが図示されている
- [x] パフォーマンス最適化が考慮されている
- [x] テストケースが具体的
- [x] 移動時間チェックのロジックが明確
- [x] **エラー時の状態復旧方法が定義されている**
- [x] **競合が発生する可能性が検討されている**

---

**このドキュメントを読了したら、INDEX_ドキュメント構成.md に戻り、次のドキュメントに進んでください。**
