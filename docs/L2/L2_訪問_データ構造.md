# L2_訪問_データ構造

**作成日**: 2025年11月23日  
**カテゴリ**: 第2層 - セクション別  
**バージョン**: 1.0

---

## 📖 このドキュメントについて

このドキュメントは、**訪問セクションのデータ構造**を定義します。

### 対象読者

- 訪問セクションの実装担当者
- データベース設計担当者
- テスト担当者

### 読了後に理解できること

- HoumonSchedule クラスの構造
- 時間指定モードの管理方法
- 移動時間マトリックスとの連携
- バリデーションルール
- 型変換の責任分担

---

## 1. データモデル概要

### 1.1 責務

**訪問セクションが管理するデータ**:
- 利用者ごとの訪問サービスの予定
- 訪問の時間帯（厳守 or ざっくり）
- 所要時間と移動時間
- 担当職員（任意）

### 1.2 データの粒度

```
1レコード = 1人 × 1日 × 1訪問
```

**重要**: 同じ日に複数回訪問する場合は、複数レコードが存在する

**例**:
```javascript
// 安藤さんが11月25日に朝と夕の2回訪問
[
  {
    id: "houmon_001",
    userId: "user001",
    date: "2025-11-25",
    timeMode: "morning",
    startTime: null,      // morningなのでnull
    endTime: null,
    duration: 30
  },
  {
    id: "houmon_002",
    userId: "user001",
    date: "2025-11-25",
    timeMode: "evening",
    startTime: null,
    endTime: null,
    duration: 30
  }
]

// 田中さんが11月25日に10:00-10:30で厳守訪問
{
  id: "houmon_003",
  userId: "user002",
  date: "2025-11-25",
  timeMode: "strict",
  startTime: "10:00",   // strictなので必須
  endTime: "10:30",
  duration: 30
}
```

---

### 1.3 月別予定表との対応

```
月別予定表（横軸: 日付、縦軸: 利用者）

        25日     26日     27日
安藤    朝・夕   昼       -
田中    10:00   朝       夕
```

**データとしての表現**:
```javascript
[
  // 安藤さん: 25日に朝・夕、26日に昼
  { userId: "user001", date: "2025-11-25", timeMode: "morning", duration: 30 },
  { userId: "user001", date: "2025-11-25", timeMode: "evening", duration: 30 },
  { userId: "user001", date: "2025-11-26", timeMode: "daytime", duration: 30 },
  
  // 田中さん: 25日に10:00（厳守）、26日に朝、27日に夕
  { userId: "user002", date: "2025-11-25", timeMode: "strict", startTime: "10:00", endTime: "10:30", duration: 30 },
  { userId: "user002", date: "2025-11-26", timeMode: "morning", duration: 30 },
  { userId: "user002", date: "2025-11-27", timeMode: "evening", duration: 30 }
]
```

---

## 2. データ構造定義

### 2.1 HoumonSchedule クラス

#### プロパティ

| プロパティ名 | 型 | 必須 | デフォルト値 | 説明 |
|------------|----|----|----------|------|
| **id** | `string` | ✓ | 自動生成 | 一意識別子（例: `"houmon_20251125_001"`） |
| **userId** | `string` | ✓ | - | 利用者ID（利用者マスタを参照） |
| **date** | `string` | ✓ | - | 訪問日（"YYYY-MM-DD"形式） |
| **timeMode** | `string` | ✓ | `"morning"` | 時間指定モード（後述） |
| **startTime** | `string \| null` | 条件付き | `null` | 開始時刻（"HH:MM"形式、timeModeが`strict`の場合は必須） |
| **endTime** | `string \| null` | 条件付き | `null` | 終了時刻（"HH:MM"形式、timeModeが`strict`の場合は必須） |
| **duration** | `number` | ✓ | `30` | 所要時間（分） |
| **staffId** | `string \| null` | - | `null` | 担当職員ID（任意） |
| **note** | `string` | - | `""` | メモ（自由記述） |

**⚠️ 型に関する注意**:
- **date**: Date型ではなく、ISO文字列（"YYYY-MM-DD"）を使用
  - 理由: セルのdate属性との比較を容易にするため
  - 変換: DateUtils.formatDate()を使用
- **startTime/endTime**: "HH:MM"形式の文字列（例: "10:00", "14:30"）
  - 時刻のみを管理（日付は含まない）
- **duration**: 分単位の整数（例: 30分 → `30`, 1時間 → `60`）

---

### 2.2 timeMode（時間指定モード）

#### 列挙値

| 値 | 表示名 | 意味 | 時刻の扱い | デフォルト時間帯（参考） |
|---|-------|------|----------|----------------------|
| **strict** | 厳守 | 開始・終了時刻を厳守 | 必須 | - |
| **morning** | 朝 | 朝の時間帯 | 任意（参考値） | 6:00-9:00 |
| **daytime** | 昼 | 昼の時間帯 | 任意（参考値） | 11:00-14:00 |
| **afternoon** | 午後 | 午後の時間帯 | 任意（参考値） | 14:00-17:00 |
| **evening** | 夕 | 夕方の時間帯 | 任意（参考値） | 17:00-20:00 |
| **night** | 夜 | 夜の時間帯 | 任意（参考値） | 20:00-22:00 |
| **anytime** | 随時 | 時間帯不問 | 不要 | - |

**TypeScript定義例**:
```typescript
type TimeMode = 
  | "strict"
  | "morning"
  | "daytime"
  | "afternoon"
  | "evening"
  | "night"
  | "anytime";
```

**デフォルト時間帯について**:
- 現バージョンでは固定値
- 将来的にカスタマイズ可能にする拡張性を残す

---

### 2.3 移動時間の管理

訪問サービスでは、職員が利用者宅を移動する際の**移動時間**が重要です。

#### 設計方針

移動時間は**HoumonScheduleオブジェクト自体には含めず**、共通データ構造の**移動時間マトリックス**を参照します。

**理由**:
- 移動時間は「地点間」の情報であり、特定の訪問予定に紐づかない
- 送迎機能でも同じマトリックスを使用（共通化）
- データの重複を避ける

#### 移動時間マトリックス（L1共通データ構造で定義）

```javascript
// L1_データ_共通データ構造.md で定義予定
travelTimeMatrix = {
  "facility": {
    "user001": 15,  // 施設 → 利用者001: 15分
    "user002": 10,  // 施設 → 利用者002: 10分
    "user003": 25,
  },
  "user001": {
    "facility": 15,  // 利用者001 → 施設: 15分
    "user002": 20,   // 利用者001 → 利用者002: 20分
    "user003": 30,
  },
  "user002": {
    "facility": 10,
    "user001": 20,
    "user003": 15,
  },
  // ...
}
```

#### 移動時間の取得方法

```javascript
// 例: 施設から利用者001への移動時間
const travelTime = travelTimeMatrix["facility"]["user001"]; // 15分

// 例: 利用者001から利用者002への移動時間
const travelTime = travelTimeMatrix["user001"]["user002"]; // 20分
```

**注意**: マトリックスに存在しない組み合わせの場合はデフォルト値（例: 20分）を使用

---

### 2.4 JavaScript実装例

```javascript
class HoumonSchedule {
  constructor({
    id = null,
    userId,
    date,
    timeMode = "morning",
    startTime = null,
    endTime = null,
    duration = 30,
    staffId = null,
    note = ""
  }) {
    this.id = id || `houmon_${date.replace(/-/g, "")}_${Date.now()}`;
    this.userId = userId;
    this.date = date;
    this.timeMode = timeMode;
    this.startTime = startTime;
    this.endTime = endTime;
    this.duration = duration;
    this.staffId = staffId;
    this.note = note;
    
    this.validate();
  }
  
  validate() {
    if (!this.userId) {
      throw new Error("userId is required");
    }
    if (!this.date) {
      throw new Error("date is required");
    }
    if (!this.isValidDate(this.date)) {
      throw new Error(`Invalid date format: ${this.date}`);
    }
    if (!this.isValidTimeMode(this.timeMode)) {
      throw new Error(`Invalid timeMode: ${this.timeMode}`);
    }
    if (this.timeMode === "strict") {
      if (!this.startTime || !this.endTime) {
        throw new Error("startTime and endTime are required when timeMode is 'strict'");
      }
      if (!this.isValidTime(this.startTime) || !this.isValidTime(this.endTime)) {
        throw new Error("Invalid time format (expected HH:MM)");
      }
    }
    if (this.duration <= 0) {
      throw new Error("duration must be greater than 0");
    }
  }
  
  isValidDate(dateStr) {
    return /^\d{4}-\d{2}-\d{2}$/.test(dateStr);
  }
  
  isValidTime(timeStr) {
    return /^([01]\d|2[0-3]):([0-5]\d)$/.test(timeStr);
  }
  
  isValidTimeMode(mode) {
    const validModes = ["strict", "morning", "daytime", "afternoon", "evening", "night", "anytime"];
    return validModes.includes(mode);
  }
  
  // 移動時間を取得（マトリックスから）
  getTravelTimeFrom(fromLocationId, travelTimeMatrix) {
    if (!travelTimeMatrix[fromLocationId]) {
      return 20; // デフォルト
    }
    return travelTimeMatrix[fromLocationId][this.userId] || 20;
  }
  
  // 時間帯の表示用文字列を取得
  getTimeDisplayString() {
    if (this.timeMode === "strict") {
      return `${this.startTime}-${this.endTime}`;
    }
    
    const timeModeLabels = {
      morning: "朝",
      daytime: "昼",
      afternoon: "午後",
      evening: "夕",
      night: "夜",
      anytime: "随時"
    };
    
    return timeModeLabels[this.timeMode] || this.timeMode;
  }
}
```

---

## 3. バリデーションルール

### 3.1 必須チェック

| プロパティ | 条件 | エラーメッセージ |
|-----------|------|---------------|
| **userId** | 常に必須 | "userId is required" |
| **date** | 常に必須 | "date is required" |
| **timeMode** | 常に必須 | "timeMode is required" |
| **startTime** | `timeMode === "strict"`の場合必須 | "startTime is required when timeMode is 'strict'" |
| **endTime** | `timeMode === "strict"`の場合必須 | "endTime is required when timeMode is 'strict'" |
| **duration** | 常に必須 | "duration is required" |

---

### 3.2 形式チェック

| プロパティ | 形式 | 正規表現 | 例 |
|-----------|------|---------|-----|
| **date** | YYYY-MM-DD | `/^\d{4}-\d{2}-\d{2}$/` | "2025-11-25" |
| **startTime** | HH:MM | `/^([01]\d\|2[0-3]):([0-5]\d)$/` | "10:00", "14:30" |
| **endTime** | HH:MM | `/^([01]\d\|2[0-3]):([0-5]\d)$/` | "10:30", "15:00" |

---

### 3.3 範囲チェック

| プロパティ | 条件 | エラーメッセージ |
|-----------|------|---------------|
| **duration** | `> 0` | "duration must be greater than 0" |
| **startTime < endTime** | `timeMode === "strict"`の場合 | "endTime must be after startTime" |

---

### 3.4 列挙値チェック

| プロパティ | 許可される値 | エラーメッセージ |
|-----------|------------|---------------|
| **timeMode** | `["strict", "morning", "daytime", "afternoon", "evening", "night", "anytime"]` | "Invalid timeMode: {value}" |

---

### 3.5 参照整合性チェック

| プロパティ | チェック内容 | エラーメッセージ |
|-----------|------------|---------------|
| **userId** | 利用者マスタに存在するか | "User not found: {userId}" |
| **staffId** | 職員マスタに存在するか（指定された場合） | "Staff not found: {staffId}" |

**注意**: 参照整合性チェックは、クラス単体ではなく、アプリケーション層で実施する

---

## 4. 型変換の責任

### 4.1 入力時の変換

#### 外部データ（CSV/Excel）からの取り込み

**責任**: インポート処理（L3層）

```javascript
// CSV例: "2025-11-25,user001,morning,30"
function importFromCSV(csvRow) {
  const [date, userId, timeMode, duration] = csvRow.split(",");
  
  return new HoumonSchedule({
    userId,
    date,
    timeMode,
    duration: parseInt(duration, 10)
  });
}
```

---

#### UI入力からの変換

**責任**: UIコンポーネント（L2_訪問_UI設計.md）

```javascript
// フォーム入力例
function createFromForm(formData) {
  return new HoumonSchedule({
    userId: formData.userId,
    date: formData.date,           // input[type="date"]から取得（"YYYY-MM-DD"形式）
    timeMode: formData.timeMode,   // selectから取得
    startTime: formData.startTime, // input[type="time"]から取得（"HH:MM"形式）
    endTime: formData.endTime,
    duration: parseInt(formData.duration, 10),
    staffId: formData.staffId || null
  });
}
```

---

### 4.2 出力時の変換

#### 画面表示用

**責任**: UIコンポーネント（L2_訪問_UI設計.md）

```javascript
// 訪問予定の表示文字列を生成
function formatForDisplay(schedule) {
  const user = userMaster.getById(schedule.userId);
  const timeStr = schedule.getTimeDisplayString(); // "朝" or "10:00-10:30"
  
  return `${user.name} ${timeStr} (${schedule.duration}分)`;
}
```

---

#### CSV/Excelエクスポート

**責任**: エクスポート処理（L3層）

```javascript
function exportToCSV(schedule) {
  return [
    schedule.date,
    schedule.userId,
    schedule.timeMode,
    schedule.startTime || "",
    schedule.endTime || "",
    schedule.duration,
    schedule.staffId || ""
  ].join(",");
}
```

---

## 5. データ操作のユースケース

### 5.1 訪問予定の追加

```javascript
// 例: 安藤さんに11月25日の朝訪問を追加
const schedule = new HoumonSchedule({
  userId: "user001",
  date: "2025-11-25",
  timeMode: "morning",
  duration: 30
});

houmonScheduleList.push(schedule);
```

---

### 5.2 訪問予定の編集

```javascript
// 例: 時間帯を「朝」から「厳守10:00-10:30」に変更
const schedule = houmonScheduleList.find(s => s.id === "houmon_001");
schedule.timeMode = "strict";
schedule.startTime = "10:00";
schedule.endTime = "10:30";
schedule.validate(); // バリデーション実行
```

---

### 5.3 訪問予定の削除

```javascript
// 例: 特定の訪問予定を削除
houmonScheduleList = houmonScheduleList.filter(s => s.id !== "houmon_001");
```

---

### 5.4 特定日の訪問予定を取得

```javascript
// 例: 11月25日の訪問予定をすべて取得
const schedules = houmonScheduleList.filter(s => s.date === "2025-11-25");

// 時間帯順にソート
schedules.sort((a, b) => {
  if (a.timeMode === "strict" && b.timeMode === "strict") {
    return a.startTime.localeCompare(b.startTime);
  }
  
  const timeModeOrder = {
    morning: 1,
    daytime: 2,
    afternoon: 3,
    evening: 4,
    night: 5,
    anytime: 6,
    strict: 0  // strictは実際の時刻でソート
  };
  
  return timeModeOrder[a.timeMode] - timeModeOrder[b.timeMode];
});
```

---

### 5.5 特定利用者の訪問回数を集計

```javascript
// 例: 安藤さんの11月の訪問回数
const count = houmonScheduleList.filter(s => 
  s.userId === "user001" && 
  s.date.startsWith("2025-11")
).length;

console.log(`安藤さんの11月の訪問回数: ${count}回`);
```

---

### 5.6 移動時間を考慮したスケジュール検証

```javascript
// 例: 連続する訪問の間に十分な移動時間があるか確認
function validateTravelTime(schedules, travelTimeMatrix) {
  const sortedSchedules = schedules
    .filter(s => s.timeMode === "strict")
    .sort((a, b) => a.startTime.localeCompare(b.startTime));
  
  for (let i = 0; i < sortedSchedules.length - 1; i++) {
    const current = sortedSchedules[i];
    const next = sortedSchedules[i + 1];
    
    // 前の訪問の終了時刻
    const currentEnd = timeToMinutes(current.endTime);
    // 次の訪問の開始時刻
    const nextStart = timeToMinutes(next.startTime);
    // 必要な移動時間
    const travelTime = current.getTravelTimeFrom(current.userId, travelTimeMatrix);
    
    const availableTime = nextStart - currentEnd;
    
    if (availableTime < travelTime) {
      console.warn(`移動時間不足: ${current.userId} → ${next.userId} (必要: ${travelTime}分, 実際: ${availableTime}分)`);
    }
  }
}

function timeToMinutes(timeStr) {
  const [hours, minutes] = timeStr.split(":").map(Number);
  return hours * 60 + minutes;
}
```

---

## 6. データ永続化

### 6.1 Phase 1（ブラウザ完結型）

**保存先**: `localStorage`

**キー**: `"houmon_schedules_YYYYMM"`（月ごと）

```javascript
// 保存
function saveToLocalStorage(schedules, year, month) {
  const key = `houmon_schedules_${year}${month.toString().padStart(2, "0")}`;
  const data = schedules.map(s => ({
    id: s.id,
    userId: s.userId,
    date: s.date,
    timeMode: s.timeMode,
    startTime: s.startTime,
    endTime: s.endTime,
    duration: s.duration,
    staffId: s.staffId,
    note: s.note
  }));
  localStorage.setItem(key, JSON.stringify(data));
}

// 読み込み
function loadFromLocalStorage(year, month) {
  const key = `houmon_schedules_${year}${month.toString().padStart(2, "0")}`;
  const data = JSON.parse(localStorage.getItem(key) || "[]");
  return data.map(d => new HoumonSchedule(d));
}
```

---

### 6.2 Phase 2（サーバー連携版）

**API設計例**:
```
GET  /api/houmon/schedules?year=2025&month=11
POST /api/houmon/schedules
PUT  /api/houmon/schedules/{id}
DELETE /api/houmon/schedules/{id}
```

---

## 7. テストケース

### 7.1 正常系

| テストケース | 入力 | 期待される結果 |
|------------|------|--------------|
| **朝訪問の作成** | `timeMode: "morning", duration: 30` | オブジェクト生成成功 |
| **厳守訪問の作成** | `timeMode: "strict", startTime: "10:00", endTime: "10:30"` | オブジェクト生成成功 |
| **時間帯表示** | `timeMode: "morning"` | `getTimeDisplayString()` → "朝" |
| **時刻表示** | `timeMode: "strict", startTime: "10:00", endTime: "10:30"` | `getTimeDisplayString()` → "10:00-10:30" |

---

### 7.2 異常系

| テストケース | 入力 | 期待されるエラー |
|------------|------|---------------|
| **userIdなし** | `userId: null` | "userId is required" |
| **dateなし** | `date: null` | "date is required" |
| **strictで時刻なし** | `timeMode: "strict", startTime: null` | "startTime is required when timeMode is 'strict'" |
| **不正な時刻形式** | `startTime: "25:00"` | "Invalid time format" |
| **duration <= 0** | `duration: 0` | "duration must be greater than 0" |
| **不正なtimeMode** | `timeMode: "invalid"` | "Invalid timeMode: invalid" |

---

## 8. 設計上の注意点

### 8.1 1日複数回訪問の扱い

訪問サービスでは、**同じ利用者が1日に複数回訪問を受ける**ことがあります。

**例**: 朝の着替え、昼の服薬確認、夕の食事介助

```javascript
// 安藤さんの11月25日の予定
[
  { userId: "user001", date: "2025-11-25", timeMode: "morning", duration: 30 },
  { userId: "user001", date: "2025-11-25", timeMode: "daytime", duration: 20 },
  { userId: "user001", date: "2025-11-25", timeMode: "evening", duration: 30 }
]
```

**UIでの表示**: 
- 月別予定表のセル内に複数表示（例: "朝・昼・夕"）
- クリックで詳細表示

---

### 8.2 時間帯の重複チェック

**注意**: 同じ日・同じ時間帯に複数の訪問を入れない

```javascript
function checkTimeConflict(newSchedule, existingSchedules) {
  const conflicts = existingSchedules.filter(s => 
    s.date === newSchedule.date &&
    s.userId === newSchedule.userId &&
    s.timeMode === newSchedule.timeMode
  );
  
  if (conflicts.length > 0) {
    console.warn(`時間帯が重複しています: ${newSchedule.date} ${newSchedule.timeMode}`);
  }
}
```

---

### 8.3 職員リソースの考慮

訪問サービスは**定員制限がない**が、**職員の時間は有限**です。

**Phase 3（調整支援機能）での拡張**:
- 職員の稼働状況を可視化
- 同時刻に複数訪問が重なっていないか警告
- 移動時間を考慮したスケジュール最適化

---

## 9. 他セクションとの関係

### 9.1 通いセクションとの関係

**連携ポイント**: 同じ日に通いと訪問を両方利用するケース

```
例: 木曜の予定
- 午前: 訪問（朝の着替え支援）
- 午後: 通い（後半のみ）
```

**データとしての表現**:
```javascript
// 訪問セクション
{ userId: "user001", date: "2025-11-25", timeMode: "morning" }

// 通いセクション
{ userId: "user001", date: "2025-11-25", section: "後半" }
```

**UI統合**: L3_UI_統合UI設計.md で定義

---

### 9.2 泊まりセクションとの関係

**連携ポイント**: 泊まっている利用者は、日中の訪問は不要

**データ上の制約**: 
- 泊まり期間中は、訪問予定を入れない（警告表示）
- ただし、入所日・退所日は訪問もあり得る

---

## 10. まとめ

### 10.1 HoumonSchedule クラスの要点

```
✓ 時間指定モード（7種類）で柔軟な管理
✓ 厳守の場合のみ時刻を必須化
✓ 所要時間を分単位で管理
✓ 移動時間はマトリックスを参照（データ重複なし）
✓ 1日複数回訪問に対応
```

---

### 10.2 次のステップ

このデータ構造定義が完成したら、以下のドキュメントに進んでください。

**次に読むべきドキュメント**:
1. **L2_訪問_UI設計.md** - このデータをどう表示するか
2. **L2_訪問_ロジック設計.md** - このデータをどう操作するか

---

## 📚 参考ドキュメント

- **L0_業務_調整業務の制約.md** - 訪問サービスの業務背景
- **L1_データ_共通データ構造.md** - 移動時間マトリックスの定義
- **L2_通い_データ構造.md** - 通いセクションとの連携
- **L2_泊まり_データ構造.md** - 泊まりセクションとの連携

---

## 📅 更新履歴

| 日付 | バージョン | 変更内容 | 担当 |
|------|----------|---------|------|
| 2025-11-23 | 1.0 | 初版作成 | Claude |

---

**最終更新**: 2025年11月23日  
**次回更新予定**: UI設計・ロジック設計の確定後

---

## ⚠️ 設計チェックリスト

このドキュメントは以下の項目をクリアしています：

- [x] すべてのプロパティの型が明記されている
- [x] Date型と文字列の使い分けが明確
- [x] 型変換の責任が明確（どこで変換するか）
- [x] null/undefinedの扱いが定義されている
- [x] バリデーションルールが網羅されている
- [x] テストケースが具体的に記述されている
- [x] 他セクションとの関係が明記されている
- [x] データ永続化の方針が明記されている
- [x] 1日複数回訪問のケースが考慮されている
- [x] 時間指定モードの柔軟性と厳密性が両立されている

---

**このドキュメントを読了したら、INDEX_ドキュメント構成.md に戻り、次のドキュメントに進んでください。**