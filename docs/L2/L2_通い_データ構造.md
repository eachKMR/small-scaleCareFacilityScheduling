# L2_通い_データ構造

**作成日**: 2025年11月23日  
**カテゴリ**: 第2層 - セクション別  
**バージョン**: 2.0

---

## 📖 このドキュメントについて

このドキュメントは、**通いセクションのデータ構造**を定義します。

### 対象読者

- 通いセクションの実装担当者
- データベース設計担当者
- テスト担当者

### 読了後に理解できること

- KayoiSchedule クラスの構造
- 前半・後半・終日の管理方法
- バリデーションルール
- 型変換の責任分担

---

## 1. データモデル概要

### 1.1 責務

**通いセクションが管理するデータ**:
- 利用者ごとの通いサービスの予定
- 日付ごとの前半・後半の区別
- 定員管理（前半15人、後半15人）

### 1.2 データの粒度

```
1レコード = 1人 × 1日 × 1セクション（前半 or 後半 or 終日）
```

**例**:
```javascript
// 安藤さんが11月25日に終日利用
{
  id: "kayoi_001",
  userId: "user001",
  date: "2025-11-25",
  section: "終日"
}

// 田中さんが11月25日に前半のみ利用
{
  id: "kayoi_002",
  userId: "user002",
  date: "2025-11-25",
  section: "前半"
}
```

---

### 1.3 月別予定表との対応

```
月別予定表（横軸: 日付、縦軸: 利用者）

        25日  26日  27日
安藤    ○    ◓    ◒
田中    ◓    -     ○

○ = 終日
◓ = 前半のみ
◒ = 後半のみ
- = 利用なし
```

**データとしての表現**:
```javascript
[
  { userId: "user001", date: "2025-11-25", section: "終日" },
  { userId: "user001", date: "2025-11-26", section: "前半" },
  { userId: "user001", date: "2025-11-27", section: "後半" },
  { userId: "user002", date: "2025-11-25", section: "前半" },
  { userId: "user002", date: "2025-11-27", section: "終日" }
]
```

---

## 2. データ構造定義

### 2.1 KayoiSchedule クラス

#### プロパティ

| プロパティ名 | 型 | 必須 | デフォルト値 | 説明 |
|------------|----|----|----------|------|
| **id** | `string` | ✓ | 自動生成 | 一意識別子（例: `"kayoi_20251125_001"`） |
| **userId** | `string` | ✓ | - | 利用者ID（例: `"user001"`） |
| **date** | `string` | ✓ | - | 日付（`"YYYY-MM-DD"` 形式） |
| **section** | `"前半"` \| `"後半"` \| `"終日"` | ✓ | - | 利用セクション |
| **startTime** | `string` | - | `null` | 開始時刻（`"HH:MM"` 形式、例: `"10:00"`） |
| **endTime** | `string` | - | `null` | 終了時刻（`"HH:MM"` 形式、例: `"15:00"`） |
| **status** | `"計画"` \| `"実施"` \| `"中止"` | - | `"計画"` | 予定の状態（Phase 1では未使用） |
| **note** | `string` | - | `null` | メモ（例: `"送迎あり"`, `"体調確認"`） |
| **createdAt** | `string` | ✓ | 自動生成 | 作成日時（ISO形式） |
| **updatedAt** | `string` | ✓ | 自動生成 | 更新日時（ISO形式） |

---

#### ⚠️ 型に関する重要な注意

**日付は文字列（"YYYY-MM-DD"）を使用**

```javascript
✅ 正しい
const schedule = {
  date: "2025-11-25"
};

❌ 間違い
const schedule = {
  date: new Date("2025-11-25") // Date型は使わない
};
```

**理由**:
- L1_技術_実装制約.md の「1.1 日付の扱い」に準拠
- HTMLの`data-date`属性との比較が容易
- タイムゾーンの問題を回避

---

#### IDの生成ルール

```javascript
// 形式: "kayoi_" + 日付 + "_" + 連番
id: "kayoi_20251125_001"
```

**生成方法**:
```javascript
function generateKayoiId(date) {
  const dateStr = date.replace(/-/g, ''); // "2025-11-25" → "20251125"
  const sequence = getNextSequence(); // 連番を取得
  return `kayoi_${dateStr}_${sequence.toString().padStart(3, '0')}`;
}
```

---

#### section（セクション）の意味

| 値 | 意味 | 記号 | 定員へのカウント |
|----|----|------|---------------|
| `"前半"` | 午前のみ利用 | ◓ | 前半に+1 |
| `"後半"` | 午後のみ利用 | ◒ | 後半に+1 |
| `"終日"` | 終日利用 | ○ | 前半と後半の両方に+1 |

**重要**: 終日利用の場合、前半と後半の**両方**にカウントされます。

---

#### startTime / endTime（時刻）の扱い

**目的**: 入力オペレータを介したCAREKARTE連携のため

**形式**: `"HH:MM"` (24時間形式)

**注意事項**:
1. **前半・後半は時刻で自動判定しない**
   - オペレータが明示的にsectionを指定
   - 例: 10:00-12:00でも「後半」と指定可能（柔軟性）

2. **時刻は必須ではない**
   - Phase 1では入力不要（null許可）
   - Phase 2以降のCAREKARTE連携時に入力

3. **利用時間は可変**
   - 最短: 1時間程度
   - 最長: 終日（約8時間）
   - 利用者ごとに異なる

**例**:
```javascript
// Phase 1: 時刻なし（従来通り）
{
  userId: "user001",
  date: "2025-11-25",
  section: "前半",
  startTime: null,
  endTime: null
}

// Phase 2: 時刻あり（CAREKARTE連携用）
{
  userId: "user001",
  date: "2025-11-25",
  section: "前半",
  startTime: "10:00",
  endTime: "15:00"
}
```

---

#### status（Phase 1では未使用）

| 値 | 意味 |
|----|----|
| `"計画"` | 予定（デフォルト） |
| `"実施"` | 実際に提供された |
| `"中止"` | キャンセル・中止 |

**Phase 1での扱い**:
- すべて`"計画"`として扱う
- Phase 2以降でCAREKARTEとの連携時に使用予定

---

### 2.2 KayoiSchedule クラスの実装例

```javascript
class KayoiSchedule {
  constructor(data) {
    this.id = data.id || this.#generateId(data.date);
    this.userId = data.userId;
    this.date = data.date;
    this.section = data.section;
    this.startTime = data.startTime || null;
    this.endTime = data.endTime || null;
    this.status = data.status || "計画";
    this.note = data.note || null;
    this.createdAt = data.createdAt || new Date().toISOString();
    this.updatedAt = data.updatedAt || new Date().toISOString();
  }

  #generateId(date) {
    const dateStr = date.replace(/-/g, '');
    const sequence = Math.floor(Math.random() * 1000); // 仮実装
    return `kayoi_${dateStr}_${sequence.toString().padStart(3, '0')}`;
  }

  validate() {
    if (!this.userId) return { valid: false, error: '利用者IDは必須です' };
    if (!this.date) return { valid: false, error: '日付は必須です' };
    if (!this.isValidDate(this.date)) {
      return { valid: false, error: '日付の形式が不正です' };
    }
    if (!this.isValidSection(this.section)) {
      return { valid: false, error: 'セクションが不正です' };
    }
    
    // 時刻のバリデーション（指定されている場合のみ）
    if (this.startTime && !this.isValidTime(this.startTime)) {
      return { valid: false, error: '開始時刻の形式が不正です（HH:MM形式）' };
    }
    if (this.endTime && !this.isValidTime(this.endTime)) {
      return { valid: false, error: '終了時刻の形式が不正です（HH:MM形式）' };
    }
    
    // 時刻の前後関係チェック
    if (this.startTime && this.endTime) {
      if (this.startTime >= this.endTime) {
        return { valid: false, error: '終了時刻は開始時刻より後である必要があります' };
      }
    }
    
    return { valid: true };
  }

  isValidDate(date) {
    // "YYYY-MM-DD" 形式のチェック
    const regex = /^\d{4}-\d{2}-\d{2}$/;
    if (!regex.test(date)) return false;
    
    // 実在する日付かチェック
    const d = new Date(date);
    return d instanceof Date && !isNaN(d.getTime());
  }

  isValidSection(section) {
    return ['前半', '後半', '終日'].includes(section);
  }

  isValidTime(time) {
    // "HH:MM" 形式のチェック
    const regex = /^([01]\d|2[0-3]):([0-5]\d)$/;
    return regex.test(time);
  }

  toJSON() {
    return {
      id: this.id,
      userId: this.userId,
      date: this.date,
      section: this.section,
      startTime: this.startTime,
      endTime: this.endTime,
      status: this.status,
      note: this.note,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt
    };
  }

  static fromJSON(json) {
    return new KayoiSchedule(json);
  }
}
```

---

## 3. バリデーションルール

### 3.1 必須チェック

| プロパティ | チェック内容 |
|-----------|------------|
| **userId** | 必須、空文字列不可 |
| **date** | 必須、空文字列不可 |
| **section** | 必須、空文字列不可 |

---

### 3.2 形式チェック

#### 3.2.1 date（日付）

**形式**: `"YYYY-MM-DD"`

**チェック**:
```javascript
function isValidDate(date) {
  // 形式チェック
  const regex = /^\d{4}-\d{2}-\d{2}$/;
  if (!regex.test(date)) return false;
  
  // 実在する日付かチェック
  const d = new Date(date);
  return d instanceof Date && !isNaN(d.getTime());
}
```

**例**:
```javascript
isValidDate("2025-11-25") // ✅ true
isValidDate("2025-02-30") // ❌ false（2月30日は存在しない）
isValidDate("2025/11/25") // ❌ false（スラッシュ区切り）
isValidDate("25-11-2025") // ❌ false（順序が違う）
```

---

#### 3.2.2 section（セクション）

**許可される値**: `"前半"`, `"後半"`, `"終日"`

**チェック**:
```javascript
function isValidSection(section) {
  return ['前半', '後半', '終日'].includes(section);
}
```

---

#### 3.2.3 startTime / endTime（時刻）

**形式**: `"HH:MM"` (24時間形式)

**チェック**:
```javascript
function isValidTime(time) {
  // null の場合は有効（オプショナル）
  if (time === null || time === undefined) return true;
  
  // "HH:MM" 形式のチェック
  const regex = /^([01]\d|2[0-3]):([0-5]\d)$/;
  return regex.test(time);
}

function validateTimeRange(startTime, endTime) {
  // 両方nullの場合は有効
  if (!startTime && !endTime) return { valid: true };
  
  // 片方だけ指定されている場合はエラー
  if (!startTime || !endTime) {
    return { 
      valid: false, 
      error: '開始時刻と終了時刻は両方指定してください' 
    };
  }
  
  // 形式チェック
  if (!isValidTime(startTime) || !isValidTime(endTime)) {
    return { 
      valid: false, 
      error: '時刻の形式が不正です（HH:MM形式）' 
    };
  }
  
  // 前後関係チェック
  if (startTime >= endTime) {
    return { 
      valid: false, 
      error: '終了時刻は開始時刻より後である必要があります' 
    };
  }
  
  return { valid: true };
}
```

**例**:
```javascript
isValidTime("10:00")  // ✅ true
isValidTime("23:59")  // ✅ true
isValidTime(null)     // ✅ true（オプショナル）
isValidTime("25:00")  // ❌ false（25時は存在しない）
isValidTime("10:60")  // ❌ false（60分は存在しない）
isValidTime("10:5")   // ❌ false（分は2桁必須）

validateTimeRange("10:00", "15:00")  // ✅ true
validateTimeRange("15:00", "10:00")  // ❌ false（逆転）
validateTimeRange("10:00", "10:00")  // ❌ false（同じ時刻）
validateTimeRange(null, null)        // ✅ true（両方null）
validateTimeRange("10:00", null)     // ❌ false（片方だけ指定）
```

---

### 3.3 重複チェック

**ルール**: 同じ`userId`と`date`と`section`の組み合わせは重複不可

**例**:
```javascript
// ❌ エラー: 同じ利用者が同じ日の同じセクションに2回登録
[
  { userId: "user001", date: "2025-11-25", section: "前半" },
  { userId: "user001", date: "2025-11-25", section: "前半" } // 重複
]

// ✅ OK: 同じ利用者が同じ日でも、セクションが違えばOK
[
  { userId: "user001", date: "2025-11-25", section: "前半" },
  { userId: "user001", date: "2025-11-25", section: "後半" }
]
```

**ただし**:
- `"終日"`の場合、前半と後半の両方に影響するため、以下は論理的に矛盾：
```javascript
// ❌ 論理的に矛盾: 終日と前半は同時に存在できない
[
  { userId: "user001", date: "2025-11-25", section: "終日" },
  { userId: "user001", date: "2025-11-25", section: "前半" }
]
```

**実装での対応**:
- 終日の予定がある場合、前半・後半の予定は登録不可
- 前半・後半の予定がある場合、終日の予定は登録不可

---

### 3.4 定員チェック

**ルール**: 前半・後半それぞれの同時利用者数が15人以下

**チェック方法**:
```javascript
function checkCapacity(schedules, date, section) {
  // 対象日の予定を抽出
  const dateSchedules = schedules.filter(s => s.date === date);
  
  // セクションごとのカウント
  let zenhanCount = 0;
  let kohanCount = 0;
  
  dateSchedules.forEach(schedule => {
    if (schedule.section === "前半" || schedule.section === "終日") {
      zenhanCount++;
    }
    if (schedule.section === "後半" || schedule.section === "終日") {
      kohanCount++;
    }
  });
  
  // セクションに応じてチェック
  if (section === "前半" && zenhanCount >= 15) {
    return { ok: false, message: "前半の定員（15人）に達しています" };
  }
  if (section === "後半" && kohanCount >= 15) {
    return { ok: false, message: "後半の定員（15人）に達しています" };
  }
  if (section === "終日" && (zenhanCount >= 15 || kohanCount >= 15)) {
    return { ok: false, message: "定員に達しています（前半または後半）" };
  }
  
  return { ok: true };
}
```

---

## 4. 型変換の責任

### 4.1 入力時の変換

#### 4.1.1 CSV/Excelからのインポート

**元データ**:
```csv
利用者ID,日付,前半,後半
user001,2025-11-25,○,
user001,2025-11-26,,○
user002,2025-11-25,○,○
```

**変換処理**:
```javascript
function convertFromCSV(csvRow) {
  const schedules = [];
  
  // 前半の記号がある場合
  if (csvRow.前半 === '○') {
    schedules.push(new KayoiSchedule({
      userId: csvRow.利用者ID,
      date: csvRow.日付,
      section: "前半"
    }));
  }
  
  // 後半の記号がある場合
  if (csvRow.後半 === '○') {
    schedules.push(new KayoiSchedule({
      userId: csvRow.利用者ID,
      date: csvRow.日付,
      section: "後半"
    }));
  }
  
  // 両方ある場合は、前半と後半を削除して終日に統合
  if (csvRow.前半 === '○' && csvRow.後半 === '○') {
    schedules.length = 0; // 前半と後半を削除
    schedules.push(new KayoiSchedule({
      userId: csvRow.利用者ID,
      date: csvRow.日付,
      section: "終日"
    }));
  }
  
  return schedules;
}
```

---

#### 4.1.2 画面からの入力

**ユーザーアクション**: セルをクリック → 記号が変化

```
空欄 → ◓ → ◒ → ○ → 空欄
```

**変換処理**:
```javascript
function handleCellClick(cell, schedules) {
  const userId = cell.dataset.userId;
  const date = cell.dataset.date;
  
  // 現在の予定を取得
  const existing = schedules.filter(s => 
    s.userId === userId && s.date === date
  );
  
  // 現在の状態を判定
  const hasZenhan = existing.some(s => s.section === "前半" || s.section === "終日");
  const hasKohan = existing.some(s => s.section === "後半" || s.section === "終日");
  
  // 次の状態に遷移
  if (!hasZenhan && !hasKohan) {
    // 空欄 → 前半
    return [new KayoiSchedule({ userId, date, section: "前半" })];
  } else if (hasZenhan && !hasKohan) {
    // 前半 → 後半
    return [new KayoiSchedule({ userId, date, section: "後半" })];
  } else if (!hasZenhan && hasKohan) {
    // 後半 → 終日
    return [new KayoiSchedule({ userId, date, section: "終日" })];
  } else {
    // 終日 → 空欄
    return [];
  }
}
```

---

### 4.2 出力時の変換

#### 4.2.1 画面表示への変換

**データ → 記号**:
```javascript
function getSymbol(schedules, userId, date) {
  const userSchedules = schedules.filter(s => 
    s.userId === userId && s.date === date
  );
  
  const hasZenhan = userSchedules.some(s => 
    s.section === "前半" || s.section === "終日"
  );
  const hasKohan = userSchedules.some(s => 
    s.section === "後半" || s.section === "終日"
  );
  
  if (hasZenhan && hasKohan) return "○"; // 終日
  if (hasZenhan) return "◓"; // 前半のみ
  if (hasKohan) return "◒"; // 後半のみ
  return ""; // 空欄
}
```

---

#### 4.2.2 CSV/Excelへのエクスポート

**データ → CSV**:
```javascript
function exportToCSV(schedules) {
  const rows = [];
  
  // 利用者×日付でグループ化
  const grouped = groupBy(schedules, s => `${s.userId}_${s.date}`);
  
  for (const [key, groupSchedules] of Object.entries(grouped)) {
    const [userId, date] = key.split('_');
    const symbol = getSymbol(groupSchedules, userId, date);
    
    rows.push({
      利用者ID: userId,
      日付: date,
      記号: symbol
    });
  }
  
  return convertToCSV(rows);
}
```

---

#### 4.2.3 localStorageへの保存

**データ → JSON**:
```javascript
function saveToStorage(schedules) {
  const data = {
    version: '1.0',
    timestamp: new Date().toISOString(),
    schedules: schedules.map(s => s.toJSON())
  };
  
  localStorage.setItem(
    'projectB:kayoi:schedules',
    JSON.stringify(data)
  );
}
```

**JSON → データ**:
```javascript
function loadFromStorage() {
  try {
    const json = localStorage.getItem('projectB:kayoi:schedules');
    if (!json) return [];
    
    const data = JSON.parse(json);
    return data.schedules.map(s => KayoiSchedule.fromJSON(s));
  } catch (error) {
    console.error('データ読み込みエラー:', error);
    return [];
  }
}
```

---

## 5. データ操作の例

### 5.1 予定の追加

```javascript
function addSchedule(schedules, userId, date, section) {
  // バリデーション
  const newSchedule = new KayoiSchedule({ userId, date, section });
  const validation = newSchedule.validate();
  if (!validation.valid) {
    throw new Error(validation.error);
  }
  
  // 重複チェック
  const duplicate = schedules.some(s => 
    s.userId === userId && s.date === date && s.section === section
  );
  if (duplicate) {
    throw new Error('既に同じ予定が存在します');
  }
  
  // 定員チェック
  const capacity = checkCapacity(schedules, date, section);
  if (!capacity.ok) {
    throw new Error(capacity.message);
  }
  
  // 追加
  schedules.push(newSchedule);
  return newSchedule;
}
```

---

### 5.2 予定の削除

```javascript
function removeSchedule(schedules, userId, date, section) {
  const index = schedules.findIndex(s => 
    s.userId === userId && s.date === date && s.section === section
  );
  
  if (index === -1) {
    throw new Error('予定が見つかりません');
  }
  
  schedules.splice(index, 1);
}
```

---

### 5.3 予定の変更

```javascript
function updateSchedule(schedules, id, updates) {
  const schedule = schedules.find(s => s.id === id);
  if (!schedule) {
    throw new Error('予定が見つかりません');
  }
  
  // 更新
  Object.assign(schedule, updates);
  schedule.updatedAt = new Date().toISOString();
  
  // バリデーション
  const validation = schedule.validate();
  if (!validation.valid) {
    throw new Error(validation.error);
  }
  
  return schedule;
}
```

---

## 6. まとめ

### 6.1 このドキュメントで定義したこと

```
✅ 定義したこと
├─ KayoiSchedule クラスの構造
├─ プロパティの型・必須・デフォルト値
├─ バリデーションルール（必須、形式、重複、定員）
├─ 型変換の責任（入力時、出力時）
└─ データ操作の例（追加、削除、変更）
```

---

### 6.2 重要なポイント

1. **日付は文字列**（"YYYY-MM-DD"）
2. **section は "前半" | "後半" | "終日"**
3. **終日は前半と後半の両方にカウント**
4. **定員は前半・後半それぞれ15人**
5. **重複は許可しない**（同じユーザー・日付・セクション）

---

### 6.3 次のステップ

このデータ構造に基づいて、UI設計とロジック設計を行います：

1. **L2_通い_UI設計.md** - グリッド表示、記号の表示
2. **L2_通い_ロジック.md** - 定員チェック、バリデーション

---

## 📚 次に読むべきドキュメント

このドキュメントを読了したら、以下のドキュメントに進んでください。

### 次のドキュメント

**L2_通い_UI設計.md**
- 月別予定表のグリッド表示
- セルのクリック処理
- 記号（○◓◒）の表示ルール

---

## 📝 参考資料

- L1_技術_実装制約.md（データ型規約）
- L0_業務_定員の法的枠組み.md（通い定員15人の根拠）
- L0_業務_介護ソフトとの関係.md（CSV連携）

---

## 📅 更新履歴

| 日付 | バージョン | 変更内容 | 担当 |
|------|----------|---------|------|
| 2025-11-23 | 1.0 | 初版作成 | Claude |
| 2025-11-23 | 2.0 | startTime/endTime追加、時刻バリデーション追加 | Claude |

---

**最終更新**: 2025年11月23日  
**次回更新予定**: Phase 1実装中のフィードバック反映時

---

## ⚠️ 設計チェックリスト

このドキュメントの品質チェック：

- [x] すべてのプロパティの型が明記されている
- [x] Date型と文字列の使い分けが明確
- [x] 型変換の責任が明確（どこで変換するか）
- [x] null/undefinedの扱いが定義されている
- [x] バリデーションルールが網羅されている

---

**このドキュメントを読了したら、INDEX_ドキュメント構成.md に戻り、次のドキュメントに進んでください。**