# L2_泊まり_ロジック設計

**作成日**: 2025年11月23日  
**カテゴリ**: 第2層 - セクション別  
**バージョン**: 1.0

---

## 📖 このドキュメントについて

このドキュメントは、**泊まりセクションのビジネスロジック**を定義します。

### 対象読者

- 泊まりセクションの実装担当者
- コードレビュー担当者
- テスト担当者

### 読了後に理解できること

- 定員チェックのアルゴリズム（9人/日）
- 期間重複チェックの実装方法
- バリデーションの詳細
- データ操作（追加、削除、更新）
- イベント処理の順序
- キャッシュ管理の方法
- エラーハンドリング

### 設計の前提

- **L2_泊まり_データ構造.md** のTomariReservationクラスに基づく
- **L2_泊まり_UI設計.md** のインタラクションに基づく
- **L1_技術_実装制約.md** に準拠

---

## 1. 定員チェックのアルゴリズム

### 1.1 基本ルール

```
泊まり定員: 9人/日（固定）

カウント方法:
指定日の宿泊者数 = startDate <= 指定日 <= endDate の予約数
```

**重要**: 1つの予約は期間中のすべての日にカウントされる

---

### 1.2 定員チェックの実装

#### 1.2.1 1日分の定員チェック

```javascript
/**
 * 指定日の宿泊者数をカウント
 * @param {TomariReservation[]} reservations - 全予約データ
 * @param {string} date - チェック対象の日付（"YYYY-MM-DD"）
 * @returns {number} 宿泊者数
 */
function countReservations(reservations, date) {
  return reservations.filter(r => 
    r.startDate <= date && date <= r.endDate
  ).length;
}
```

---

#### 1.2.2 期間全体の定員チェック

```javascript
/**
 * 指定期間のすべての日の定員をチェック
 * @param {TomariReservation[]} reservations - 現在の全予約データ
 * @param {string} startDate - チェック対象の開始日
 * @param {string} endDate - チェック対象の終了日
 * @returns {Object} { ok: boolean, message?: string, overDates?: string[] }
 */
function checkCapacity(reservations, startDate, endDate) {
  const CAPACITY = 9;
  const overDates = [];
  
  // 期間内のすべての日をチェック
  const dates = getDateRange(startDate, endDate);
  
  for (const date of dates) {
    const count = countReservations(reservations, date);
    
    if (count >= CAPACITY) {
      overDates.push({ date, count });
    }
  }
  
  if (overDates.length > 0) {
    const dateList = overDates.map(d => `${d.date}(${d.count}人)`).join(', ');
    return {
      ok: false,
      message: `以下の日が定員に達しています: ${dateList}`,
      overDates: overDates.map(d => d.date)
    };
  }
  
  return { ok: true };
}

/**
 * 日付範囲を配列で取得
 * @param {string} startDate - 開始日
 * @param {string} endDate - 終了日
 * @returns {string[]} 日付の配列
 */
function getDateRange(startDate, endDate) {
  const dates = [];
  let current = new Date(startDate);
  const end = new Date(endDate);
  
  while (current <= end) {
    dates.push(current.toISOString().split('T')[0]);
    current.setDate(current.getDate() + 1);
  }
  
  return dates;
}
```

---

#### 1.2.3 定員チェックのテストケース

```javascript
describe('checkCapacity', () => {
  test('全日程で余裕あり（8人）→ OK', () => {
    const reservations = Array(8).fill(null).map((_, i) => ({
      userId: `user${i}`,
      roomId: `room0${i + 1}`,
      startDate: "2025-11-01",
      endDate: "2025-11-03"
    }));
    
    const result = checkCapacity(reservations, "2025-11-01", "2025-11-03");
    expect(result.ok).toBe(true);
  });
  
  test('満員（9人）→ NG', () => {
    const reservations = Array(9).fill(null).map((_, i) => ({
      userId: `user${i}`,
      roomId: `room0${(i % 9) + 1}`,
      startDate: "2025-11-01",
      endDate: "2025-11-03"
    }));
    
    const result = checkCapacity(reservations, "2025-11-01", "2025-11-03");
    expect(result.ok).toBe(false);
    expect(result.overDates).toEqual(["2025-11-01", "2025-11-02", "2025-11-03"]);
  });
  
  test('期間の一部だけ満員 → NG（該当日のみリスト）', () => {
    const reservations = [
      // 11/1-11/2: 8人
      ...Array(8).fill(null).map((_, i) => ({
        userId: `user${i}`,
        roomId: `room0${i + 1}`,
        startDate: "2025-11-01",
        endDate: "2025-11-02"
      })),
      // 11/2-11/3: +1人（11/2だけ9人になる）
      {
        userId: "user999",
        roomId: "room09",
        startDate: "2025-11-02",
        endDate: "2025-11-03"
      }
    ];
    
    const result = checkCapacity(reservations, "2025-11-01", "2025-11-03");
    expect(result.ok).toBe(false);
    expect(result.overDates).toEqual(["2025-11-02"]);
  });
});
```

---

## 2. 期間重複チェック

### 2.1 重複判定のロジック

**ルール**: 同じ居室で期間が重複する予約は不可

```
期間Aと期間Bが重複しない条件（どちらか）:
1. A.endDate < B.startDate （Aの後にB）
2. B.endDate < A.startDate （Bの後にA）

→ 重複する条件（否定）:
!(A.endDate < B.startDate || B.endDate < A.startDate)
```

---

### 2.2 実装

```javascript
/**
 * 居室の期間重複をチェック
 * @param {TomariReservation[]} reservations - 現在の全予約データ
 * @param {string} roomId - チェック対象の居室ID
 * @param {string} startDate - チェック対象の開始日
 * @param {string} endDate - チェック対象の終了日
 * @param {string} excludeId - 除外する予約ID（編集時に使用）
 * @returns {Object} { valid: boolean, error?: string, conflictReservation?: Object }
 */
function checkRoomConflict(reservations, roomId, startDate, endDate, excludeId = null) {
  // 同じ居室の予約を抽出
  const roomReservations = reservations.filter(r => 
    r.roomId === roomId && r.id !== excludeId
  );
  
  // 期間が重複する予約を検索
  const conflict = roomReservations.find(r => {
    // 重複判定
    return !(r.endDate < startDate || endDate < r.startDate);
  });
  
  if (conflict) {
    return {
      valid: false,
      error: `${roomId}は${conflict.startDate}～${conflict.endDate}に既に予約されています`,
      conflictReservation: conflict
    };
  }
  
  return { valid: true };
}
```

---

### 2.3 テストケース

```javascript
describe('checkRoomConflict', () => {
  const existingReservation = {
    id: "tomari_001",
    userId: "user001",
    roomId: "room01",
    startDate: "2025-11-10",
    endDate: "2025-11-15"
  };
  
  test('完全に前 → OK', () => {
    const result = checkRoomConflict(
      [existingReservation],
      "room01",
      "2025-11-05",  // 既存の前
      "2025-11-09"
    );
    expect(result.valid).toBe(true);
  });
  
  test('完全に後 → OK', () => {
    const result = checkRoomConflict(
      [existingReservation],
      "room01",
      "2025-11-16",  // 既存の後
      "2025-11-20"
    );
    expect(result.valid).toBe(true);
  });
  
  test('前日まで → OK', () => {
    const result = checkRoomConflict(
      [existingReservation],
      "room01",
      "2025-11-08",
      "2025-11-09"  // 既存の開始日の前日
    );
    expect(result.valid).toBe(true);
  });
  
  test('翌日から → OK', () => {
    const result = checkRoomConflict(
      [existingReservation],
      "room01",
      "2025-11-16",  // 既存の終了日の翌日
      "2025-11-20"
    );
    expect(result.valid).toBe(true);
  });
  
  test('開始日が同じ → NG', () => {
    const result = checkRoomConflict(
      [existingReservation],
      "room01",
      "2025-11-10",  // 既存と同じ開始日
      "2025-11-12"
    );
    expect(result.valid).toBe(false);
  });
  
  test('期間の途中 → NG', () => {
    const result = checkRoomConflict(
      [existingReservation],
      "room01",
      "2025-11-12",  // 既存の期間内
      "2025-11-14"
    );
    expect(result.valid).toBe(false);
  });
  
  test('期間を包含 → NG', () => {
    const result = checkRoomConflict(
      [existingReservation],
      "room01",
      "2025-11-08",  // 既存より前から
      "2025-11-18"   // 既存より後まで
    );
    expect(result.valid).toBe(false);
  });
  
  test('別の居室 → OK', () => {
    const result = checkRoomConflict(
      [existingReservation],
      "room02",  // 別の居室
      "2025-11-10",
      "2025-11-15"
    );
    expect(result.valid).toBe(true);
  });
});
```

---

## 3. バリデーション

### 3.1 バリデーションの階層

```
レベル1: クライアント側（即座）
  ├─ 入力時のバリデーション（型、形式）
  ├─ 日付の前後関係
  └─ 期間の長さ

レベル2: データ層（保存前）
  ├─ 必須チェック
  ├─ 期間重複チェック
  ├─ 定員チェック
  └─ データ整合性チェック

（Phase 2以降）
レベル3: サーバー側
  └─ 最終的なバリデーション
```

---

### 3.2 入力時のバリデーション

#### 3.2.1 日付の形式チェック

```javascript
/**
 * 日付形式のバリデーション
 * @param {string} date - チェック対象の日付
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateDate(date) {
  if (!date) {
    return { valid: false, error: '日付は必須です' };
  }
  
  // 形式チェック（YYYY-MM-DD）
  const regex = /^\d{4}-\d{2}-\d{2}$/;
  if (!regex.test(date)) {
    return { 
      valid: false, 
      error: '日付の形式が不正です（YYYY-MM-DD形式で入力してください）' 
    };
  }
  
  // 実在する日付かチェック
  const d = new Date(date);
  if (isNaN(d.getTime())) {
    return { valid: false, error: '実在しない日付です' };
  }
  
  return { valid: true };
}
```

---

#### 3.2.2 日付の前後関係チェック

```javascript
/**
 * 日付の前後関係のバリデーション
 * @param {string} startDate - 開始日
 * @param {string} endDate - 終了日
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateDateRange(startDate, endDate) {
  // 形式チェック
  const startValidation = validateDate(startDate);
  if (!startValidation.valid) return startValidation;
  
  const endValidation = validateDate(endDate);
  if (!endValidation.valid) return endValidation;
  
  // 前後関係チェック
  if (startDate >= endDate) {
    return { 
      valid: false, 
      error: '退所日は入所日より後である必要があります' 
    };
  }
  
  // 期間が長すぎないかチェック（例: 30日以内）
  const start = new Date(startDate);
  const end = new Date(endDate);
  const diffDays = Math.ceil((end - start) / (1000 * 60 * 60 * 24));
  
  if (diffDays > 30) {
    return { 
      valid: false, 
      error: '宿泊期間は30日以内にしてください' 
    };
  }
  
  return { valid: true };
}
```

---

#### 3.2.3 利用者ID・居室IDのチェック

```javascript
/**
 * 利用者IDのバリデーション
 * @param {string} userId - チェック対象の利用者ID
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateUserId(userId) {
  if (!userId) {
    return { valid: false, error: '利用者IDは必須です' };
  }
  
  if (typeof userId !== 'string') {
    return { valid: false, error: '利用者IDは文字列でなければなりません' };
  }
  
  return { valid: true };
}

/**
 * 居室IDのバリデーション
 * @param {string} roomId - チェック対象の居室ID
 * @param {Room[]} rooms - 居室マスタ
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateRoomId(roomId, rooms) {
  if (!roomId) {
    return { valid: false, error: '居室IDは必須です' };
  }
  
  // 居室マスタに存在するかチェック
  const room = rooms.find(r => r.id === roomId);
  if (!room) {
    return { valid: false, error: '指定された居室が見つかりません' };
  }
  
  // 使用可能かチェック
  if (!room.isActive) {
    return { valid: false, error: 'この居室は現在使用できません' };
  }
  
  return { valid: true };
}
```

---

### 3.3 保存前のバリデーション

#### 3.3.1 統合バリデーション関数

```javascript
/**
 * 予約追加時の統合バリデーション
 * @param {TomariReservation[]} reservations - 現在の全予約データ
 * @param {Room[]} rooms - 居室マスタ
 * @param {string} userId - 利用者ID
 * @param {string} roomId - 居室ID
 * @param {string} startDate - 開始日
 * @param {string} endDate - 終了日
 * @returns {Object} { valid: boolean, errors?: string[], warnings?: string[] }
 */
function validateReservationAdd(reservations, rooms, userId, roomId, startDate, endDate) {
  const errors = [];
  const warnings = [];
  
  // 利用者IDチェック
  const userIdValidation = validateUserId(userId);
  if (!userIdValidation.valid) {
    errors.push(userIdValidation.error);
  }
  
  // 居室IDチェック
  const roomIdValidation = validateRoomId(roomId, rooms);
  if (!roomIdValidation.valid) {
    errors.push(roomIdValidation.error);
  }
  
  // 日付範囲チェック
  const dateRangeValidation = validateDateRange(startDate, endDate);
  if (!dateRangeValidation.valid) {
    errors.push(dateRangeValidation.error);
  }
  
  // エラーがあれば、以降のチェックはスキップ
  if (errors.length > 0) {
    return { valid: false, errors };
  }
  
  // 期間重複チェック
  const conflictCheck = checkRoomConflict(reservations, roomId, startDate, endDate);
  if (!conflictCheck.valid) {
    errors.push(conflictCheck.error);
  }
  
  // 定員チェック（警告のみ、エラーではない）
  const capacityCheck = checkCapacity(reservations, startDate, endDate);
  if (!capacityCheck.ok) {
    warnings.push(capacityCheck.message);
  }
  
  return {
    valid: errors.length === 0,
    errors: errors.length > 0 ? errors : undefined,
    warnings: warnings.length > 0 ? warnings : undefined
  };
}
```

---

## 4. データ操作

### 4.1 予約の追加

```javascript
/**
 * 予約を追加
 * @param {TomariReservation[]} reservations - 現在の全予約データ（破壊的変更）
 * @param {Room[]} rooms - 居室マスタ
 * @param {string} userId - 利用者ID
 * @param {string} roomId - 居室ID
 * @param {string} startDate - 開始日
 * @param {string} endDate - 終了日
 * @returns {Object} { success: boolean, reservation?: TomariReservation, errors?: string[], warnings?: string[] }
 */
function addReservation(reservations, rooms, userId, roomId, startDate, endDate) {
  // バリデーション
  const validation = validateReservationAdd(reservations, rooms, userId, roomId, startDate, endDate);
  if (!validation.valid) {
    return { 
      success: false, 
      errors: validation.errors 
    };
  }
  
  // 新しい予約を作成
  const newReservation = new TomariReservation({
    userId: userId,
    roomId: roomId,
    startDate: startDate,
    endDate: endDate
  });
  
  // 配列に追加
  reservations.push(newReservation);
  
  // イベント発火
  dispatchReservationEvent('tomari:reservationAdded', {
    reservation: newReservation
  });
  
  return { 
    success: true, 
    reservation: newReservation,
    warnings: validation.warnings  // 定員超過の警告
  };
}
```

---

### 4.2 予約の削除

```javascript
/**
 * 予約を削除
 * @param {TomariReservation[]} reservations - 現在の全予約データ（破壊的変更）
 * @param {string} reservationId - 予約ID
 * @returns {Object} { success: boolean, error?: string }
 */
function removeReservation(reservations, reservationId) {
  const index = reservations.findIndex(r => r.id === reservationId);
  
  if (index === -1) {
    return { 
      success: false, 
      error: '予約が見つかりません' 
    };
  }
  
  // 削除される予約を保持（イベント用）
  const removedReservation = reservations[index];
  
  // 配列から削除
  reservations.splice(index, 1);
  
  // イベント発火
  dispatchReservationEvent('tomari:reservationRemoved', {
    reservation: removedReservation
  });
  
  return { success: true };
}
```

---

### 4.3 予約の更新

```javascript
/**
 * 予約を更新
 * @param {TomariReservation[]} reservations - 現在の全予約データ（破壊的変更）
 * @param {Room[]} rooms - 居室マスタ
 * @param {string} reservationId - 予約ID
 * @param {Object} updates - 更新内容 { roomId?, startDate?, endDate? }
 * @returns {Object} { success: boolean, reservation?: TomariReservation, errors?: string[], warnings?: string[] }
 */
function updateReservation(reservations, rooms, reservationId, updates) {
  const reservation = reservations.find(r => r.id === reservationId);
  if (!reservation) {
    return { 
      success: false, 
      error: '予約が見つかりません' 
    };
  }
  
  // 更新後の値を取得
  const newRoomId = updates.roomId || reservation.roomId;
  const newStartDate = updates.startDate || reservation.startDate;
  const newEndDate = updates.endDate || reservation.endDate;
  
  // バリデーション（自分自身を除外）
  const validation = validateReservationAdd(
    reservations, 
    rooms, 
    reservation.userId, 
    newRoomId, 
    newStartDate, 
    newEndDate
  );
  
  // 期間重複チェック（自分自身を除外）
  const conflictCheck = checkRoomConflict(
    reservations, 
    newRoomId, 
    newStartDate, 
    newEndDate, 
    reservationId  // 自分自身を除外
  );
  
  if (!conflictCheck.valid) {
    return { 
      success: false, 
      errors: [conflictCheck.error] 
    };
  }
  
  // 更新
  Object.assign(reservation, updates);
  reservation.updatedAt = new Date().toISOString();
  
  // イベント発火
  dispatchReservationEvent('tomari:reservationUpdated', {
    reservation: reservation
  });
  
  return { 
    success: true, 
    reservation: reservation,
    warnings: validation.warnings
  };
}
```

---

## 5. イベント処理の順序

### 5.1 期間選択（ドラッグ）時の処理フロー

```
1. ユーザーがセルでマウスダウン（開始）
   ↓
2. マウス移動（期間選択）
   - 通過したセルをハイライト
   - 同じ居室の横方向のみ選択可能
   ↓
3. マウスアップ（終了）
   - 選択解除
   ↓
4. 利用者選択ダイアログ表示
   showUserSelectDialog(roomId, startDate, endDate)
   ↓
5. 利用者を選択 → [追加]ボタン
   ↓
6. バリデーション
   validateReservationAdd()
   ↓ 成功
7. データ追加
   addReservation()
   ↓
8. キャッシュ無効化
   invalidateCache(reservation)
   ↓
9. UI更新
   renderGrid()
   ↓
10. 定員表示を更新
    updateCapacityDisplay()
    ↓
11. トースト通知（成功 or 警告）
    if (warnings) {
      showWarning(warnings);
    } else {
      showToast('予約を追加しました', 'info');
    }
    ↓
12. localStorage に保存
    saveToStorage(reservations)

---

エラー時:
6. バリデーション
   ↓ 失敗（期間重複等）
7. エラー処理
   ↓
8. トースト通知（エラー）
   showToast('この期間は既に予約されています', 'error')
   ↓
9. 処理終了（データは更新されない）
```

---

### 5.2 イベントの優先順位

```
優先度1: バリデーション
  - データの整合性を最優先

優先度2: データ更新
  - バリデーション成功後のみ実行

優先度3: キャッシュ無効化
  - データ更新成功後に必ず実行

優先度4: UI更新
  - キャッシュ無効化後に実行

優先度5: 通知・保存
  - UI更新後に実行
```

---

### 5.3 イベント発火のタイミング

```javascript
// イベント発火関数
function dispatchReservationEvent(eventName, detail) {
  const event = new CustomEvent(eventName, { detail });
  document.dispatchEvent(event);
}

// 使用例
addReservation() {
  // ...データ追加
  dispatchReservationEvent('tomari:reservationAdded', {
    reservation: newReservation
  });
}

// リスナー（他のセクションやコンポーネント）
document.addEventListener('tomari:reservationAdded', (e) => {
  console.log('泊まりで予約追加:', e.detail.reservation);
  // 必要なら何かする
});
```

**イベント一覧**:
- `tomari:reservationAdded` - 予約追加時
- `tomari:reservationRemoved` - 予約削除時
- `tomari:reservationUpdated` - 予約更新時
- `tomari:capacityExceeded` - 定員超過時（警告）

---

## 6. キャッシュ管理

### 6.1 キャッシュの目的

**問題**: 居室視点の表示のたびに計算 → 重い

**解決策**: 計算結果をキャッシュ

```javascript
class TomariSection {
  #reservations = [];
  #occupancyCache = new Map();  // key: "roomId_date", value: { userId, status, userName }
  
  getRoomOccupancy(roomId, date) {
    const key = `${roomId}_${date}`;
    
    // キャッシュにあれば返す
    if (this.#occupancyCache.has(key)) {
      return this.#occupancyCache.get(key);
    }
    
    // 計算＋キャッシュに保存
    const result = this.calculateOccupancy(roomId, date);
    this.#occupancyCache.set(key, result);
    
    return result;
  }
}
```

---

### 6.2 キャッシュの無効化

**ルール**: 予約を追加・削除・更新したら、関連する日付のキャッシュを削除

```javascript
class TomariSection {
  /**
   * キャッシュを無効化（予約追加・削除・更新時に呼ぶ）
   * @param {TomariReservation} reservation - 対象の予約
   */
  invalidateCache(reservation) {
    // この予約に関連する日付のキャッシュを削除
    const dates = this.getDateRange(reservation.startDate, reservation.endDate);
    
    dates.forEach(date => {
      this.#occupancyCache.delete(`${reservation.roomId}_${date}`);
    });
  }
  
  /**
   * すべてのキャッシュを無効化
   */
  invalidateAllCache() {
    this.#occupancyCache.clear();
  }
  
  /**
   * 予約追加（キャッシュ無効化を忘れない）
   */
  addReservation(reservation) {
    this.#reservations.push(reservation);
    this.invalidateCache(reservation);  // ← 必須
  }
  
  /**
   * 予約削除（キャッシュ無効化を忘れない）
   */
  removeReservation(reservationId) {
    const reservation = this.#reservations.find(r => r.id === reservationId);
    if (!reservation) return { success: false };
    
    // 削除前にキャッシュを無効化（予約情報が必要なため）
    this.invalidateCache(reservation);
    
    // 削除
    this.#reservations = this.#reservations.filter(r => r.id !== reservationId);
    
    return { success: true };
  }
  
  /**
   * 予約更新（キャッシュ無効化を忘れない）
   */
  updateReservation(reservationId, updates) {
    const reservation = this.#reservations.find(r => r.id === reservationId);
    if (!reservation) return { success: false };
    
    // 更新前の期間のキャッシュを無効化
    this.invalidateCache(reservation);
    
    // 更新
    Object.assign(reservation, updates);
    
    // 更新後の期間のキャッシュも無効化（期間が変わった場合）
    this.invalidateCache(reservation);
    
    return { success: true };
  }
}
```

---

### 6.3 キャッシュのライフサイクル

```
1. 初期状態: キャッシュは空
   ↓
2. 表示時: getRoomOccupancy() で計算＋キャッシュに保存
   ↓
3. 予約追加・削除・更新: invalidateCache() でキャッシュを削除
   ↓
4. 次回表示時: 再計算＋キャッシュに保存
```

**重要**: 予約を追加・削除・更新したら、**必ず**キャッシュを無効化する

---

## 7. エラーハンドリング

### 7.1 エラーの分類

| エラー分類 | 例 | 処理 |
|-----------|----|----|
| **バリデーションエラー** | 日付形式が不正、期間の前後関係 | トースト通知、処理中断 |
| **期間重複エラー** | 同じ居室で期間が重複 | トースト通知、処理中断 |
| **定員超過エラー** | 9人超過 | トースト通知（警告）、処理続行 |
| **システムエラー** | localStorage書き込み失敗 | エラーログ、ユーザーに通知 |

---

### 7.2 エラーハンドリングの実装

```javascript
function handleReservationAdd(roomId, startDate, endDate, userId) {
  try {
    // 予約追加
    const result = addReservation(reservations, rooms, userId, roomId, startDate, endDate);
    
    if (!result.success) {
      // エラー処理
      handleAddError(result.errors);
      return;
    }
    
    // 警告がある場合（定員超過）
    if (result.warnings) {
      showWarning(result.warnings.join('\n'));
    }
    
    // UI更新
    renderGrid();
    updateCapacityDisplay();
    
    // 成功通知
    showToast('予約を追加しました', 'info');
    
    // 保存
    saveToStorage(reservations);
    
  } catch (error) {
    // システムエラー
    console.error('予約追加エラー:', error);
    showToast('システムエラーが発生しました', 'error');
  }
}

function handleAddError(errors) {
  // エラーメッセージを表示
  const errorMessage = errors.join('\n');
  showToast(errorMessage, 'error');
}
```

---

### 7.3 エラーログの記録

```javascript
function logError(error, context) {
  const log = {
    timestamp: new Date().toISOString(),
    error: error.message,
    stack: error.stack,
    context: context
  };
  
  // コンソールに出力
  console.error('Error:', log);
  
  // Phase 2以降: サーバーに送信
  // sendErrorLog(log);
}
```

---

## 8. 状態管理

### 8.1 状態の定義

```javascript
class TomariSection {
  #reservations = [];      // 全予約データ
  #rooms = [];             // 居室マスタ
  #currentMonth = null;    // 現在表示中の月
  #selectedCells = [];     // 現在選択中のセル（期間選択中）
  #isDirty = false;        // 未保存の変更があるか
  
  constructor(rooms) {
    this.#reservations = [];
    this.#rooms = rooms;
    this.#currentMonth = new Date();
    this.#selectedCells = [];
    this.#isDirty = false;
  }
  
  // getter/setter
  get reservations() {
    return [...this.#reservations]; // コピーを返す
  }
  
  get rooms() {
    return [...this.#rooms]; // コピーを返す
  }
  
  get currentMonth() {
    return this.#currentMonth;
  }
  
  set currentMonth(month) {
    this.#currentMonth = month;
    this.render();
  }
  
  get isDirty() {
    return this.#isDirty;
  }
}
```

---

### 8.2 状態の更新

```javascript
class TomariSection {
  addReservation(userId, roomId, startDate, endDate) {
    const result = addReservation(this.#reservations, this.#rooms, userId, roomId, startDate, endDate);
    
    if (result.success) {
      this.invalidateCache(result.reservation);
      this.#isDirty = true;
      this.render();
      return result;
    }
    
    return result;
  }
  
  removeReservation(reservationId) {
    const reservation = this.#reservations.find(r => r.id === reservationId);
    if (!reservation) return { success: false };
    
    this.invalidateCache(reservation);
    
    const result = removeReservation(this.#reservations, reservationId);
    
    if (result.success) {
      this.#isDirty = true;
      this.render();
      return result;
    }
    
    return result;
  }
  
  save() {
    if (!this.#isDirty) {
      return { success: true, message: '保存する変更がありません' };
    }
    
    try {
      saveToStorage(this.#reservations);
      this.#isDirty = false;
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
}
```

---

## 9. まとめ

### 9.1 このドキュメントで定義したこと

```
✅ 定義したこと
├─ 定員チェックのアルゴリズム（9人/日）
├─ 期間重複チェックの実装
├─ バリデーションの階層（入力時、保存前）
├─ データ操作（追加、削除、更新）
├─ イベント処理の順序（12ステップ）
├─ キャッシュ管理（無効化タイミング）
├─ エラーハンドリング（分類、処理、ログ）
└─ 状態管理（プライベート変数、getter/setter）
```

---

### 9.2 重要なポイント

1. **定員チェック**: 期間内のすべての日をチェック
2. **期間重複チェック**: 同じ居室で期間が重複しないか
3. **定員超過でも保存可能**: 弾力運用、警告のみ
4. **キャッシュ管理**: 予約追加・削除・更新時に必ず無効化
5. **イベント順序**: バリデーション → データ更新 → キャッシュ無効化 → UI更新

---

### 9.3 テストすべき項目

```
単体テスト:
├─ countReservations() - 定員カウントの正確性
├─ checkCapacity() - 定員チェックの正確性
├─ checkRoomConflict() - 期間重複チェック
├─ validateDateRange() - 日付範囲のバリデーション
└─ getDateRange() - 日付範囲の生成

統合テスト:
├─ addReservation() - 予約追加の一連の流れ
├─ removeReservation() - 予約削除の一連の流れ
├─ updateReservation() - 予約更新の一連の流れ
└─ キャッシュの整合性

エッジケース:
├─ 定員ギリギリでの追加（9人目）
├─ 期間の境界（前日、翌日）
├─ 長期間の予約（30日）
└─ 月をまたぐ予約
```

---

### 9.4 次のステップ

泊まりセクションの設計（データ、UI、ロジック）が完了しました。

**次に作成すべきドキュメント**:
1. **L2_訪問_データ構造.md** - 訪問セクションの設計
2. **L2_訪問_UI設計.md**
3. **L2_訪問_ロジック設計.md**

---

## 📚 次に読むべきドキュメント

このドキュメントを読了したら、以下のドキュメントに進んでください。

### 次のドキュメント

**L2_訪問_データ構造.md**
- 訪問セクションの予定データ
- 時間帯別管理
- 回数カウント

---

## 📝 参考資料

- L2_泊まり_データ構造.md（TomariReservationクラス）
- L2_泊まり_UI設計.md（インタラクション、期間選択）
- L1_技術_実装制約.md（エラーハンドリング、パフォーマンス）
- L2_通い_ロジック設計.md（通いセクションとの対比）

---

## 📅 更新履歴

| 日付 | バージョン | 変更内容 | 担当 |
|------|----------|---------|------|
| 2025-11-23 | 1.0 | 初版作成 | Claude |

---

**最終更新**: 2025年11月23日  
**次回更新予定**: Phase 1実装中のフィードバック反映時

---

## ⚠️ 設計チェックリスト

このドキュメントの品質チェック：

- [x] イベントの発火順序が文書化されている
- [x] イベントの優先順位が決まっている
- [x] 競合が発生する可能性が検討されている（期間重複）
- [x] 状態遷移が明確（期間選択の流れ）
- [x] 各状態での挙動が定義されている
- [x] エラー時の状態復旧方法が定義されている

---

**このドキュメントを読了したら、INDEX_ドキュメント構成.md に戻り、次のドキュメントに進んでください。**