# L2_通い_ロジック

**作成日**: 2025年11月23日  
**カテゴリ**: 第2層 - セクション別  
**バージョン**: 2.0

---

## 📖 このドキュメントについて

このドキュメントは、**通いセクションのビジネスロジック**を定義します。

### 対象読者

- 通いセクションの実装担当者
- コードレビュー担当者
- テスト担当者

### 読了後に理解できること

- 定員チェックのアルゴリズム
- バリデーションの実装方法
- データ操作の詳細
- イベント処理の順序
- エラーハンドリング
- 状態管理の方法

### 設計の前提

- **L2_通い_データ構造.md** のKayoiScheduleクラスに基づく
- **L2_通い_UI設計.md** のインタラクションに基づく
- **L1_技術_実装制約.md** に準拠

---

## 1. 定員チェックのアルゴリズム

### 1.1 基本ルール（再掲）

```
通い定員: 前半15人、後半15人（それぞれ独立）

カウント方法:
- 前半: section === "前半" or "終日"
- 後半: section === "後半" or "終日"
```

**重要**: 終日利用は前半と後半の**両方**にカウント

---

### 1.2 定員チェックの実装

#### 1.2.1 基本関数

```javascript
/**
 * 指定日の前半・後半の利用者数をカウント
 * @param {KayoiSchedule[]} schedules - 全予定データ
 * @param {string} date - チェック対象の日付（"YYYY-MM-DD"）
 * @returns {Object} { zenhan: number, kohan: number }
 */
function countSchedules(schedules, date) {
  // 対象日の予定を抽出
  const dateSchedules = schedules.filter(s => s.date === date);
  
  let zenhanCount = 0;
  let kohanCount = 0;
  
  dateSchedules.forEach(schedule => {
    if (schedule.section === "前半" || schedule.section === "終日") {
      zenhanCount++;
    }
    if (schedule.section === "後半" || schedule.section === "終日") {
      kohanCount++;
    }
  });
  
  return { zenhan: zenhanCount, kohan: kohanCount };
}
```

---

#### 1.2.2 定員チェック関数

```javascript
/**
 * 指定日・セクションに予定を追加できるかチェック
 * @param {KayoiSchedule[]} schedules - 現在の全予定データ
 * @param {string} date - チェック対象の日付
 * @param {string} section - チェック対象のセクション（"前半"|"後半"|"終日"）
 * @returns {Object} { ok: boolean, message?: string, counts?: Object }
 */
function checkCapacity(schedules, date, section) {
  const counts = countSchedules(schedules, date);
  const CAPACITY = 15;
  
  // 前半のチェック
  if (section === "前半" || section === "終日") {
    if (counts.zenhan >= CAPACITY) {
      return {
        ok: false,
        message: `前半の定員（${CAPACITY}人）に達しています（現在${counts.zenhan}人）`,
        counts: counts
      };
    }
  }
  
  // 後半のチェック
  if (section === "後半" || section === "終日") {
    if (counts.kohan >= CAPACITY) {
      return {
        ok: false,
        message: `後半の定員（${CAPACITY}人）に達しています（現在${counts.kohan}人）`,
        counts: counts
      };
    }
  }
  
  return { ok: true, counts: counts };
}
```

---

#### 1.2.3 定員チェックのテストケース

```javascript
describe('checkCapacity', () => {
  test('前半14人、後半14人 → 前半追加OK', () => {
    const schedules = [
      // 前半14人分のダミーデータ
      ...Array(14).fill(null).map((_, i) => ({
        userId: `user${i}`,
        date: "2025-11-25",
        section: "前半"
      })),
      // 後半14人分のダミーデータ
      ...Array(14).fill(null).map((_, i) => ({
        userId: `user${i + 14}`,
        date: "2025-11-25",
        section: "後半"
      }))
    ];
    
    const result = checkCapacity(schedules, "2025-11-25", "前半");
    expect(result.ok).toBe(true);
  });
  
  test('前半15人 → 前半追加NG', () => {
    const schedules = Array(15).fill(null).map((_, i) => ({
      userId: `user${i}`,
      date: "2025-11-25",
      section: "前半"
    }));
    
    const result = checkCapacity(schedules, "2025-11-25", "前半");
    expect(result.ok).toBe(false);
    expect(result.message).toContain('前半の定員');
  });
  
  test('終日14人 → 終日追加OK', () => {
    const schedules = Array(14).fill(null).map((_, i) => ({
      userId: `user${i}`,
      date: "2025-11-25",
      section: "終日"
    }));
    
    const result = checkCapacity(schedules, "2025-11-25", "終日");
    expect(result.ok).toBe(true);
  });
  
  test('前半14人、後半15人 → 終日追加NG（後半が満員）', () => {
    const schedules = [
      ...Array(14).fill(null).map((_, i) => ({
        userId: `user${i}`,
        date: "2025-11-25",
        section: "前半"
      })),
      { userId: "user999", date: "2025-11-25", section: "後半" }
    ];
    
    const result = checkCapacity(schedules, "2025-11-25", "終日");
    expect(result.ok).toBe(false);
    expect(result.message).toContain('後半の定員');
  });
});
```

---

## 2. バリデーション

### 2.1 バリデーションの階層

```
レベル1: クライアント側（即座）
  ├─ 入力時のバリデーション（型、形式）
  └─ 定員チェック

レベル2: データ層（保存前）
  ├─ 必須チェック
  ├─ 重複チェック
  └─ データ整合性チェック

（Phase 2以降）
レベル3: サーバー側
  └─ 最終的なバリデーション
```

---

### 2.2 入力時のバリデーション

#### 2.2.1 日付の形式チェック

```javascript
/**
 * 日付形式のバリデーション
 * @param {string} date - チェック対象の日付
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateDate(date) {
  // null/undefinedチェック
  if (!date) {
    return { valid: false, error: '日付は必須です' };
  }
  
  // 形式チェック（YYYY-MM-DD）
  const regex = /^\d{4}-\d{2}-\d{2}$/;
  if (!regex.test(date)) {
    return { 
      valid: false, 
      error: '日付の形式が不正です（YYYY-MM-DD形式で入力してください）' 
    };
  }
  
  // 実在する日付かチェック
  const d = new Date(date);
  if (isNaN(d.getTime())) {
    return { valid: false, error: '実在しない日付です' };
  }
  
  // 範囲チェック（過去1年〜未来1年）
  const now = new Date();
  const oneYearAgo = new Date(now.getFullYear() - 1, now.getMonth(), now.getDate());
  const oneYearLater = new Date(now.getFullYear() + 1, now.getMonth(), now.getDate());
  
  if (d < oneYearAgo || d > oneYearLater) {
    return { 
      valid: false, 
      error: '日付の範囲が不正です（過去1年〜未来1年の範囲で入力してください）' 
    };
  }
  
  return { valid: true };
}
```

---

#### 2.2.2 利用者IDのチェック

```javascript
/**
 * 利用者IDのバリデーション
 * @param {string} userId - チェック対象の利用者ID
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateUserId(userId) {
  if (!userId) {
    return { valid: false, error: '利用者IDは必須です' };
  }
  
  if (typeof userId !== 'string') {
    return { valid: false, error: '利用者IDは文字列でなければなりません' };
  }
  
  // 利用者マスタに存在するかチェック（Phase 1では簡略化）
  // const userExists = checkUserExists(userId);
  // if (!userExists) {
  //   return { valid: false, error: '利用者が見つかりません' };
  // }
  
  return { valid: true };
}
```

---

#### 2.2.3 セクションのチェック

```javascript
/**
 * セクションのバリデーション
 * @param {string} section - チェック対象のセクション
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateSection(section) {
  if (!section) {
    return { valid: false, error: 'セクションは必須です' };
  }
  
  const validSections = ['前半', '後半', '終日'];
  if (!validSections.includes(section)) {
    return { 
      valid: false, 
      error: `セクションが不正です（${validSections.join('、')}のいずれかを指定してください）` 
    };
  }
  
  return { valid: true };
}
```

---

### 2.3 保存前のバリデーション

#### 2.3.1 重複チェック

```javascript
/**
 * 重複チェック
 * @param {KayoiSchedule[]} schedules - 現在の全予定データ
 * @param {string} userId - 利用者ID
 * @param {string} date - 日付
 * @param {string} section - セクション
 * @returns {Object} { valid: boolean, error?: string }
 */
function checkDuplicate(schedules, userId, date, section) {
  const duplicate = schedules.some(s => 
    s.userId === userId && 
    s.date === date && 
    s.section === section
  );
  
  if (duplicate) {
    return { 
      valid: false, 
      error: '既に同じ予定が存在します' 
    };
  }
  
  return { valid: true };
}
```

---

#### 2.3.2 論理的矛盾チェック

```javascript
/**
 * 論理的矛盾チェック（終日と前半/後半の同時存在）
 * @param {KayoiSchedule[]} schedules - 現在の全予定データ
 * @param {string} userId - 利用者ID
 * @param {string} date - 日付
 * @param {string} newSection - 追加しようとしているセクション
 * @returns {Object} { valid: boolean, error?: string }
 */
function checkLogicalConflict(schedules, userId, date, newSection) {
  const userSchedules = schedules.filter(s => 
    s.userId === userId && s.date === date
  );
  
  const hasZenshu = userSchedules.some(s => s.section === "終日");
  const hasZenhan = userSchedules.some(s => s.section === "前半");
  const hasKohan = userSchedules.some(s => s.section === "後半");
  
  // 終日を追加しようとしている場合
  if (newSection === "終日") {
    if (hasZenhan || hasKohan) {
      return {
        valid: false,
        error: '既に前半または後半の予定が存在するため、終日の予定は追加できません'
      };
    }
  }
  
  // 前半または後半を追加しようとしている場合
  if (newSection === "前半" || newSection === "後半") {
    if (hasZenshu) {
      return {
        valid: false,
        error: '既に終日の予定が存在するため、前半または後半の予定は追加できません'
      };
    }
  }
  
  return { valid: true };
}
```

---

### 2.4 統合バリデーション関数

```javascript
/**
 * 予定追加時の統合バリデーション
 * @param {KayoiSchedule[]} schedules - 現在の全予定データ
 * @param {string} userId - 利用者ID
 * @param {string} date - 日付
 * @param {string} section - セクション
 * @returns {Object} { valid: boolean, errors?: string[] }
 */
function validateScheduleAdd(schedules, userId, date, section) {
  const errors = [];
  
  // 日付チェック
  const dateValidation = validateDate(date);
  if (!dateValidation.valid) {
    errors.push(dateValidation.error);
  }
  
  // 利用者IDチェック
  const userIdValidation = validateUserId(userId);
  if (!userIdValidation.valid) {
    errors.push(userIdValidation.error);
  }
  
  // セクションチェック
  const sectionValidation = validateSection(section);
  if (!sectionValidation.valid) {
    errors.push(sectionValidation.error);
  }
  
  // 重複チェック
  const duplicateCheck = checkDuplicate(schedules, userId, date, section);
  if (!duplicateCheck.valid) {
    errors.push(duplicateCheck.error);
  }
  
  // 論理的矛盾チェック
  const conflictCheck = checkLogicalConflict(schedules, userId, date, section);
  if (!conflictCheck.valid) {
    errors.push(conflictCheck.error);
  }
  
  // 定員チェック
  const capacityCheck = checkCapacity(schedules, date, section);
  if (!capacityCheck.ok) {
    errors.push(capacityCheck.message);
  }
  
  return {
    valid: errors.length === 0,
    errors: errors.length > 0 ? errors : undefined
  };
}
```

---

## 3. データ操作

### 3.1 予定の追加

```javascript
/**
 * 予定を追加
 * @param {KayoiSchedule[]} schedules - 現在の全予定データ（破壊的変更）
 * @param {string} userId - 利用者ID
 * @param {string} date - 日付
 * @param {string} section - セクション
 * @returns {Object} { success: boolean, schedule?: KayoiSchedule, errors?: string[] }
 */
function addSchedule(schedules, userId, date, section) {
  // バリデーション
  const validation = validateScheduleAdd(schedules, userId, date, section);
  if (!validation.valid) {
    return { 
      success: false, 
      errors: validation.errors 
    };
  }
  
  // 新しい予定を作成
  const newSchedule = new KayoiSchedule({
    userId: userId,
    date: date,
    section: section
  });
  
  // 配列に追加
  schedules.push(newSchedule);
  
  // イベント発火
  dispatchScheduleEvent('kayoi:scheduleAdded', {
    schedule: newSchedule
  });
  
  return { 
    success: true, 
    schedule: newSchedule 
  };
}
```

---

### 3.2 予定の削除

```javascript
/**
 * 予定を削除
 * @param {KayoiSchedule[]} schedules - 現在の全予定データ（破壊的変更）
 * @param {string} userId - 利用者ID
 * @param {string} date - 日付
 * @param {string} section - セクション
 * @returns {Object} { success: boolean, error?: string }
 */
function removeSchedule(schedules, userId, date, section) {
  const index = schedules.findIndex(s => 
    s.userId === userId && 
    s.date === date && 
    s.section === section
  );
  
  if (index === -1) {
    return { 
      success: false, 
      error: '予定が見つかりません' 
    };
  }
  
  // 削除されるスケジュールを保持（イベント用）
  const removedSchedule = schedules[index];
  
  // 配列から削除
  schedules.splice(index, 1);
  
  // イベント発火
  dispatchScheduleEvent('kayoi:scheduleRemoved', {
    schedule: removedSchedule
  });
  
  return { success: true };
}
```

---

### 3.3 予定の更新（記号の遷移）

```javascript
/**
 * 予定を更新（記号の遷移）
 * @param {KayoiSchedule[]} schedules - 現在の全予定データ（破壊的変更）
 * @param {string} userId - 利用者ID
 * @param {string} date - 日付
 * @returns {Object} { success: boolean, newSection?: string, errors?: string[] }
 */
function updateSchedule(schedules, userId, date) {
  // 現在の状態を取得
  const userSchedules = schedules.filter(s => 
    s.userId === userId && s.date === date
  );
  
  const hasZenhan = userSchedules.some(s => s.section === "前半" || s.section === "終日");
  const hasKohan = userSchedules.some(s => s.section === "後半" || s.section === "終日");
  
  // 状態遷移の決定
  let nextSection;
  let shouldRemoveAll = false;
  
  if (!hasZenhan && !hasKohan) {
    // 空欄 → 前半
    nextSection = "前半";
  } else if (hasZenhan && !hasKohan) {
    // 前半 → 後半
    // 既存の前半を削除して後半を追加
    removeSchedule(schedules, userId, date, "前半");
    nextSection = "後半";
  } else if (!hasZenhan && hasKohan) {
    // 後半 → 終日
    // 既存の後半を削除して終日を追加
    removeSchedule(schedules, userId, date, "後半");
    nextSection = "終日";
  } else {
    // 終日 → 空欄
    // 既存の終日を削除
    removeSchedule(schedules, userId, date, "終日");
    shouldRemoveAll = true;
  }
  
  if (shouldRemoveAll) {
    return { success: true, newSection: null };
  }
  
  // 新しい予定を追加
  const result = addSchedule(schedules, userId, date, nextSection);
  
  if (result.success) {
    return { 
      success: true, 
      newSection: nextSection 
    };
  } else {
    // 追加に失敗した場合（定員超過等）
    // 元の状態に戻す必要があるが、既に削除してしまっている...
    // → トランザクション的な処理が必要
    return { 
      success: false, 
      errors: result.errors 
    };
  }
}
```

**⚠️ 重要な問題点**: 
上記の実装では、状態遷移の途中で失敗した場合、元に戻せない。

**解決策**: トランザクション的な処理（後述）

---

### 3.4 トランザクション的な予定更新

```javascript
/**
 * 予定を更新（トランザクション的）
 * @param {KayoiSchedule[]} schedules - 現在の全予定データ（破壊的変更）
 * @param {string} userId - 利用者ID
 * @param {string} date - 日付
 * @returns {Object} { success: boolean, newSection?: string, errors?: string[] }
 */
function updateScheduleTransaction(schedules, userId, date) {
  // 現在の状態をバックアップ
  const backup = schedules
    .filter(s => s.userId === userId && s.date === date)
    .map(s => ({ ...s }));
  
  try {
    // 現在の状態を取得
    const userSchedules = schedules.filter(s => 
      s.userId === userId && s.date === date
    );
    
    const hasZenhan = userSchedules.some(s => 
      s.section === "前半" || s.section === "終日"
    );
    const hasKohan = userSchedules.some(s => 
      s.section === "後半" || s.section === "終日"
    );
    
    // 既存の予定をすべて削除
    schedules = schedules.filter(s => 
      !(s.userId === userId && s.date === date)
    );
    
    // 次の状態を決定して追加
    let nextSection;
    
    if (!hasZenhan && !hasKohan) {
      nextSection = "前半";
    } else if (hasZenhan && !hasKohan) {
      nextSection = "後半";
    } else if (!hasZenhan && hasKohan) {
      nextSection = "終日";
    } else {
      // 終日 → 空欄（何も追加しない）
      return { success: true, newSection: null };
    }
    
    // バリデーション
    const validation = validateScheduleAdd(schedules, userId, date, nextSection);
    if (!validation.valid) {
      // ロールバック
      backup.forEach(s => schedules.push(s));
      return { 
        success: false, 
        errors: validation.errors 
      };
    }
    
    // 追加
    const newSchedule = new KayoiSchedule({
      userId: userId,
      date: date,
      section: nextSection
    });
    schedules.push(newSchedule);
    
    // イベント発火
    dispatchScheduleEvent('kayoi:scheduleUpdated', {
      schedule: newSchedule,
      previousSchedules: backup
    });
    
    return { 
      success: true, 
      newSection: nextSection 
    };
    
  } catch (error) {
    // ロールバック
    schedules = schedules.filter(s => 
      !(s.userId === userId && s.date === date)
    );
    backup.forEach(s => schedules.push(s));
    
    return { 
      success: false, 
      errors: [error.message] 
    };
  }
}
```

**注意**: JavaScriptの配列は参照渡しなので、上記の実装では配列自体の置き換えができない。実際の実装では、KayoiSectionクラスの内部で管理する。

---

## 4. イベント処理の順序

### 4.1 セルクリック時の処理フロー

```
1. ユーザーがセルをクリック
   ↓
2. イベントハンドラーが発火
   event.target.closest('.schedule-cell')
   ↓
3. userId, date を取得
   cell.dataset.userId
   cell.dataset.date
   ↓
4. 現在の状態を取得
   getSchedules(userId, date)
   ↓
5. 次の状態を決定
   空欄 → ◓ → ◒ → ○ → 空欄
   ↓
6. バリデーション
   validateScheduleAdd()
   ↓ 成功
7. データ更新
   updateScheduleTransaction()
   ↓
8. UI更新
   cell.querySelector('.symbol').textContent = nextSymbol
   ↓
9. 定員表示を更新
   updateCapacityDisplay()
   ↓
10. アニメーション
    cell.classList.add('updated')
    setTimeout(() => cell.classList.remove('updated'), 200)
    ↓
11. トースト通知（成功）
    showToast('予定を更新しました', 'info')
    ↓
12. localStorage に保存
    saveToStorage(schedules)

---

エラー時:
6. バリデーション
   ↓ 失敗（定員超過等）
7. エラー処理
   ↓
8. UI更新（エラー表示）
   cell.classList.add('over-capacity')
   setTimeout(() => cell.classList.remove('over-capacity'), 1000)
   ↓
9. トースト通知（エラー）
   showToast('定員に達しています', 'error')
   ↓
10. 処理終了（データは更新されない）
```

---

### 4.2 イベントの優先順位

```
優先度1: バリデーション
  - データの整合性を最優先

優先度2: データ更新
  - バリデーション成功後のみ実行

優先度3: UI更新
  - データ更新成功後のみ実行

優先度4: 通知・保存
  - UI更新後に実行
```

---

### 4.3 イベント発火のタイミング

```javascript
// イベント発火関数
function dispatchScheduleEvent(eventName, detail) {
  const event = new CustomEvent(eventName, { detail });
  document.dispatchEvent(event);
}

// 使用例
addSchedule() {
  // ...データ追加
  dispatchScheduleEvent('kayoi:scheduleAdded', {
    schedule: newSchedule
  });
}

// リスナー（他のセクションやコンポーネント）
document.addEventListener('kayoi:scheduleAdded', (e) => {
  console.log('通いで予定追加:', e.detail.schedule);
  // 必要なら何かする
});
```

**イベント一覧**:
- `kayoi:scheduleAdded` - 予定追加時
- `kayoi:scheduleRemoved` - 予定削除時
- `kayoi:scheduleUpdated` - 予定更新時
- `kayoi:capacityExceeded` - 定員超過時

---

## 5. エラーハンドリング

### 5.1 エラーの分類

| エラー分類 | 例 | 処理 |
|-----------|----|----|
| **バリデーションエラー** | 日付形式が不正、必須項目が空 | トースト通知、処理中断 |
| **定員超過エラー** | 前半15人、後半15人 | トースト通知、セル点滅、処理中断 |
| **重複エラー** | 同じ予定が既に存在 | トースト通知、処理中断 |
| **システムエラー** | localStorage書き込み失敗 | エラーログ、ユーザーに通知 |

---

### 5.2 エラーハンドリングの実装

```javascript
function handleCellClick(event) {
  try {
    const cell = event.target.closest('.schedule-cell');
    if (!cell) return;
    
    const userId = cell.dataset.userId;
    const date = cell.dataset.date;
    
    // 予定更新
    const result = updateScheduleTransaction(schedules, userId, date);
    
    if (!result.success) {
      // エラー処理
      handleUpdateError(cell, result.errors);
      return;
    }
    
    // UI更新
    updateCellDisplay(cell, result.newSection);
    updateCapacityDisplay();
    
    // 成功通知
    showToast('予定を更新しました', 'info');
    
    // 保存
    saveToStorage(schedules);
    
  } catch (error) {
    // システムエラー
    console.error('予定更新エラー:', error);
    showToast('システムエラーが発生しました', 'error');
  }
}

function handleUpdateError(cell, errors) {
  // セルを点滅
  cell.classList.add('over-capacity');
  setTimeout(() => cell.classList.remove('over-capacity'), 1000);
  
  // エラーメッセージを表示
  const errorMessage = errors.join('\n');
  showToast(errorMessage, 'error');
}
```

---

### 5.3 エラーログの記録

```javascript
function logError(error, context) {
  const log = {
    timestamp: new Date().toISOString(),
    error: error.message,
    stack: error.stack,
    context: context
  };
  
  // コンソールに出力
  console.error('Error:', log);
  
  // Phase 2以降: サーバーに送信
  // sendErrorLog(log);
}
```

---

## 6. 状態管理

### 6.1 状態の定義

```javascript
class KayoiSection {
  #schedules = [];      // 全予定データ
  #currentMonth = null; // 現在表示中の月
  #selectedCell = null; // 現在選択中のセル
  #isDirty = false;     // 未保存の変更があるか
  
  constructor() {
    this.#schedules = [];
    this.#currentMonth = new Date();
    this.#selectedCell = null;
    this.#isDirty = false;
  }
  
  // getter/setter
  get schedules() {
    return [...this.#schedules]; // コピーを返す
  }
  
  get currentMonth() {
    return this.#currentMonth;
  }
  
  set currentMonth(month) {
    this.#currentMonth = month;
    this.render();
  }
  
  get isDirty() {
    return this.#isDirty;
  }
}
```

---

### 6.2 状態の更新

```javascript
class KayoiSection {
  addSchedule(userId, date, section) {
    const result = addSchedule(this.#schedules, userId, date, section);
    
    if (result.success) {
      this.#isDirty = true;
      this.render();
      return result;
    }
    
    return result;
  }
  
  removeSchedule(userId, date, section) {
    const result = removeSchedule(this.#schedules, userId, date, section);
    
    if (result.success) {
      this.#isDirty = true;
      this.render();
      return result;
    }
    
    return result;
  }
  
  save() {
    if (!this.#isDirty) {
      return { success: true, message: '保存する変更がありません' };
    }
    
    try {
      saveToStorage(this.#schedules);
      this.#isDirty = false;
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
}
```

---

### 6.3 状態のリセット

```javascript
class KayoiSection {
  reset() {
    if (this.#isDirty) {
      const confirmed = confirm('未保存の変更があります。破棄してリセットしますか？');
      if (!confirmed) {
        return { success: false, message: 'キャンセルされました' };
      }
    }
    
    this.#schedules = [];
    this.#currentMonth = new Date();
    this.#selectedCell = null;
    this.#isDirty = false;
    this.render();
    
    return { success: true };
  }
}
```

---

## 7. パフォーマンス最適化

### 7.1 定員カウントのキャッシュ

**問題**: 定員チェックのたびに全データをフィルタリング → 重い

**解決策**: 日付ごとの定員カウントをキャッシュ

```javascript
class KayoiSection {
  #capacityCache = new Map(); // key: date, value: { zenhan, kohan }
  
  countSchedules(date) {
    // キャッシュにあれば返す
    if (this.#capacityCache.has(date)) {
      return this.#capacityCache.get(date);
    }
    
    // 計算
    const counts = countSchedules(this.#schedules, date);
    
    // キャッシュに保存
    this.#capacityCache.set(date, counts);
    
    return counts;
  }
  
  invalidateCache(date) {
    this.#capacityCache.delete(date);
  }
  
  invalidateAllCache() {
    this.#capacityCache.clear();
  }
  
  addSchedule(userId, date, section) {
    const result = addSchedule(this.#schedules, userId, date, section);
    
    if (result.success) {
      this.invalidateCache(date); // キャッシュを無効化
      this.#isDirty = true;
      this.render();
    }
    
    return result;
  }
}
```

---

### 7.2 レンダリングの最適化

**問題**: 予定を1つ追加するたびに全グリッドを再描画 → 遅い

**解決策**: 変更されたセルのみ更新

```javascript
function updateCellOnly(userId, date, newSymbol) {
  const cell = document.querySelector(
    `.schedule-cell[data-user-id="${userId}"][data-date="${date}"]`
  );
  
  if (cell) {
    cell.querySelector('.symbol').textContent = newSymbol;
    
    // アニメーション
    cell.classList.add('updated');
    setTimeout(() => cell.classList.remove('updated'), 200);
  }
}
```

---

## 8. まとめ

### 8.1 このドキュメントで定義したこと

```
✅ 定義したこと
├─ 定員チェックのアルゴリズム（前半・後半のカウント）
├─ バリデーションの階層（入力時、保存前、サーバー側）
├─ データ操作（追加、削除、更新、トランザクション）
├─ イベント処理の順序（12ステップ）
├─ エラーハンドリング（分類、処理、ログ）
├─ 状態管理（プライベート変数、getter/setter）
└─ パフォーマンス最適化（キャッシュ、差分更新）
```

---

### 8.2 重要なポイント

1. **定員チェック**: 前半と後半を独立してカウント、終日は両方にカウント
2. **トランザクション**: 状態遷移の途中で失敗した場合、ロールバック
3. **イベント順序**: バリデーション → データ更新 → UI更新 → 通知・保存
4. **エラーハンドリング**: エラー分類、セル点滅、トースト通知
5. **状態管理**: プライベート変数、isDirtyフラグ

---

### 8.3 テストすべき項目

```
単体テスト:
├─ countSchedules() - 定員カウントの正確性
├─ checkCapacity() - 定員チェックの正確性
├─ validateDate() - 日付バリデーション
├─ validateSection() - セクションバリデーション
├─ checkDuplicate() - 重複チェック
└─ checkLogicalConflict() - 論理的矛盾チェック

統合テスト:
├─ addSchedule() - 予定追加の一連の流れ
├─ removeSchedule() - 予定削除の一連の流れ
├─ updateScheduleTransaction() - 予定更新の一連の流れ
└─ handleCellClick() - UI操作からデータ更新まで

エッジケース:
├─ 定員ギリギリでの追加
├─ 終日と前半/後半の同時追加
├─ 存在しない日付の追加
└─ 範囲外の日付の追加
```

---

### 8.4 次のステップ

通いセクションの設計（データ、UI、ロジック）が完了しました。

**次に作成すべきドキュメント**:
1. **L2_泊まり_データ構造.md** - 泊まりセクションの設計
2. **L2_訪問_データ構造.md** - 訪問セクションの設計
3. その後、L1_データ_共通データ構造.md で共通部分を抽出

---

## 📚 次に読むべきドキュメント

このドキュメントを読了したら、以下のドキュメントに進んでください。

### 次のドキュメント

**L2_泊まり_データ構造.md**
- 泊まりセクションの予約データ
- 居室管理
- 期間管理（入→○→退）

---

## 📝 参考資料

- L2_通い_データ構造.md（KayoiScheduleクラス）
- L2_通い_UI設計.md（インタラクション、状態遷移）
- L1_技術_実装制約.md（エラーハンドリング、パフォーマンス）

---

## 📅 更新履歴

| 日付 | バージョン | 変更内容 | 担当 |
|------|----------|---------|------|
| 2025-11-23 | 1.0 | 初版作成 | Claude |

---

**最終更新**: 2025年11月23日  
**次回更新予定**: Phase 1実装中のフィードバック反映時

---

## ⚠️ 設計チェックリスト

このドキュメントの品質チェック：

- [x] イベントの発火順序が文書化されている
- [x] イベントの優先順位が決まっている
- [x] 競合が発生する可能性が検討されている（トランザクション）
- [x] 状態遷移図が作成されている（データ構造文書に記載）
- [x] 各状態での挙動が定義されている
- [x] エラー時の状態復旧方法が定義されている（ロールバック）

---

**このドキュメントを読了したら、INDEX_ドキュメント構成.md に戻り、次のドキュメントに進んでください。**