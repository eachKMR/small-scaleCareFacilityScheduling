# L1_技術_実装制約

**作成日**: 2025年11月23日  
**カテゴリ**: 第1層 - 基礎  
**バージョン**: 1.2


**更新日**: 2026年01月03日
---

## 📖 このドキュメントについて


### v1.2での変更

- **セクション7.3追加**: StorageUtils使用規約（詳細はL2に分離）
- **セクション7.4追加**: データマイグレーション規約（詳細はL2に分離）
- **背景**: 実装制約は最小限のルールのみ、詳細実装仕様はL2層に分離

このドキュメントは、**プロジェクトBの実装時に遵守すべき最小限のルール**をまとめたものです。

### 対象読者

- プロジェクトBの実装担当者（GitHub Copilot含む）
- 設計担当者（Claude）
- コードレビュー担当者

### 読了後に理解できること

- データ型の統一ルール
- セクション独立性の実装方法
- UI/UXの実装規約
- エラーハンドリングの方針
- コメント規約

### このドキュメントの位置づけ

```
L1_技術_実装制約.md（このドキュメント）
  ↓ 型規約を提供
L2_各セクション_データ構造.md
  ↓ 詳細設計を提供
実装（GitHub Copilot）
```

**重要な原則**:
- このドキュメントでは**最小限のルールのみ**を定義
- **各セクション固有の詳細はL2層で定義**
- 過剰な抽象化を避ける（YAGNI原則）

---

## 1. データ型規約

### 1.1 日付の扱い

#### ルール

**日付は文字列（ISO 8601形式）で統一する**

```javascript
✅ 正しい
const date = "2025-11-23";
const startDate = "2025-11-25";

❌ 間違い
const date = new Date("2025-11-23");
const startDate = new Date(2025, 10, 25); // Date型
```

#### 形式

- **型**: `string`
- **形式**: `"YYYY-MM-DD"`
- **例**: `"2025-11-23"`

#### 理由

1. **HTMLのdata属性との整合性**
   ```html
   <td data-date="2025-11-23">...</td>
   ```
   - セルのdata-date属性と比較が容易
   - 型変換が不要

2. **比較の容易さ**
   ```javascript
   // 文字列比較で日付の前後判定が可能
   if (date1 < date2) { ... }
   ```

3. **JSONとの親和性**
   - JSON.stringify/parseで型が失われない
   - localStorageへの保存が容易

4. **タイムゾーンの問題を回避**
   - Date型はタイムゾーンに依存
   - 文字列なら日付だけを扱える

#### 変換

**必要な場合のみ変換する**

```javascript
// 文字列 → Date（表示用）
const dateObj = new Date(dateStr);
const displayText = dateObj.toLocaleDateString('ja-JP');

// Date → 文字列（保存用）
const dateStr = dateObj.toISOString().split('T')[0];
```

**共通ユーティリティを使用**

```javascript
// DateUtils.js を使用（L1_データ_共通データ構造.mdで定義）
const dateObj = DateUtils.parseDate(dateStr);
const dateStr = DateUtils.formatDate(dateObj);
```

---

### 1.2 ID（識別子）の扱い

#### ルール

**すべてのIDは文字列で統一する**

```javascript
✅ 正しい
const userId = "user001";
const roomId = "room01";
const scheduleId = "schedule_20251123_001";

❌ 間違い
const userId = 1;
const roomId = 1;
```

#### 理由

1. **将来の拡張性**
   - 数値だけでなく、英数字混在のIDも扱える
   - UUIDなど他の形式への移行が容易

2. **型変換の回避**
   - DOM属性との比較で型変換不要
   - JSON保存時に型が保たれる

3. **ゼロ埋めの問題を回避**
   - `001` と `1` を区別できる

#### 形式

- **型**: `string`
- **推奨形式**: 英数字とアンダースコア
- **例**: 
  - 利用者ID: `"user001"`, `"user_tanaka"`
  - 居室ID: `"room01"`, `"room_101"`

---

### 1.3 数値の扱い

#### ルール

**数値は`number`型を使用**

```javascript
✅ 正しい
const capacity = 15;
const currentCount = 12;
const ratio = 0.8;

❌ 間違い
const capacity = "15"; // 文字列
```

#### 例外：IDは文字列

```javascript
✅ 正しい
const userId = "001"; // IDは文字列

❌ 間違い
const userId = 1; // 数値にしない
```

---

### 1.4 null と undefined の使い分け

#### ルール

**明示的な「値なし」には`null`を使用、未初期化には`undefined`**

```javascript
✅ 正しい
// 初期化前（まだ設定されていない）
let selectedDate = undefined;

// 明示的に「値なし」（意図的に空）
let selectedUserId = null;

❌ 間違い
// undefined と null を混在させない
let selectedDate = null; // 初期化前なのに null
let selectedUserId = undefined; // 意図的に空なのに undefined
```

#### 具体例

```javascript
class KayoiSection {
  #selectedDate = undefined; // まだ選択されていない
  #selectedUserId = null;    // 「選択なし」の状態
  
  selectDate(date) {
    this.#selectedDate = date; // 選択された
  }
  
  clearSelection() {
    this.#selectedDate = undefined; // 選択解除（元の状態に戻す）
    this.#selectedUserId = null;    // 「選択なし」にする
  }
}
```

#### チェック方法

```javascript
// undefined チェック
if (typeof selectedDate === 'undefined') { ... }

// null チェック
if (selectedUserId === null) { ... }

// どちらもない（falsy）チェック
if (!selectedDate) { ... } // undefined, null 両方に対応
```

---

### 1.5 真偽値の扱い

#### ルール

**真偽値は`boolean`型を使用、文字列や数値で代用しない**

```javascript
✅ 正しい
const isSelected = true;
const hasError = false;

❌ 間違い
const isSelected = "true"; // 文字列
const hasError = 0; // 数値
```

---

## 2. セクション独立性の規約

### 2.1 基本原則

**3つのセクション（通い・泊まり・訪問）は互いに依存しない**

```
通いセクション
  ├─ 独自のデータ構造
  ├─ 独自のUI
  └─ 独自のロジック

泊まりセクション
  ├─ 独自のデータ構造
  ├─ 独自のUI
  └─ 独自のロジック

訪問セクション
  ├─ 独自のデータ構造
  ├─ 独自のUI
  └─ 独自のロジック

→ 相互に直接依存しない
```

**参照**: L1_概要_プロジェクト概要.md の「4. セクション独立性の原則」

---
### 2.2 データ構造の独立

#### ルール

**データクラス同士は互いに参照しない（独立性）**

```javascript
✅ 正しい - データクラスは独立
// 通いデータクラス
class UserScheduleData {
  userId;
  kayoiSchedule;  // 通い情報
  tomariPeriod;   // 泊まり期間（表示用に持つのはOK）
}

// 泊まりデータクラス
class TomariReservation {
  userId;
  roomId;
  startDate;
  endDate;
  // UserScheduleDataを参照しない
}

❌ 間違い - データクラス間の参照
class UserScheduleData {
  userId;
  kayoiSchedule;
  tomariReservation;  // ❌ TomariReservationクラスへの参照
}
```

**UIクラスは複数のデータクラスを扱ってOK**

```javascript
✅ 正しい - UIクラスは複数データを扱える
class KayoiUI {
  constructor(kayoiData, tomariData) {
    this.kayoiData = kayoiData;    // 通いデータ
    this.tomariData = tomariData;  // 泊まりデータも使う（罫線表示のため）
  }
  
  renderCell(userId, date) {
    // 通いデータから記号を取得
    const symbol = this.kayoiData.getSymbol(userId, date);
    
    // 泊まりデータから罫線状態を取得
    const border = this.tomariData.getBorderState(userId, date);
    
    // 両方を使って描画（これはOK）
    return `<div class="${border}">${symbol}</div>`;
  }
  
  handleLongPress(userId, date) {
    // 通いUIが泊まりデータを作成（これもOK）
    this.tomariData.add({
      userId,
      roomId: null,  // 未割当
      startDate,
      endDate
    });
  }
}

❌ 間違い - UIクラスが他UIのDOMを操作
class KayoiUI {
  render() {
    // 泊まりUIのDOMを直接操作（これはNG）
    document.querySelector('#tomari-section .cell').textContent = '...';
  }
}
```

**重要なポイント**:
1. **データクラスの独立**: UserScheduleDataとTomariReservationは互いを知らない
2. **UIクラスの自由**: KayoiUIがkayoiDataとtomariDataを扱うのはOK
3. **DOM操作の制限**: UIクラスは自分のDOM領域のみ操作


---


### 2.3 UI表示の独立

#### ルール

**各セクションは専用のDOM領域のみを操作する**

```html
<!-- HTML構造 -->
<div id="app">
  <div id="kayoi-section">...</div>
  <div id="tomari-section">...</div>
  <div id="homon-section">...</div>
</div>
```

```javascript
✅ 正しい
// 通いセクション
class KayoiSection {
  render() {
    const container = document.querySelector('#kayoi-section');
    container.innerHTML = '...';
  }
}

// 泊まりセクション
class TomariSection {
  render() {
    const container = document.querySelector('#tomari-section');
    container.innerHTML = '...';
  }
}

❌ 間違い
// 通いセクションが泊まりのDOMを操作
class KayoiSection {
  render() {
    const tomariCell = document.querySelector('#tomari-section .cell');
    tomariCell.textContent = '...'; // ❌ 他セクションのDOM操作
  }
}
```

---

### 2.4 ビジネスロジックの独立

#### ルール

**各セクションは自分のロジックのみを持つ**

```javascript
✅ 正しい
// 通いセクション
class KayoiSection {
  checkCapacity(date, section) {
    const count = this.#schedules.filter(s => 
      s.date === date && s.section === section
    ).length;
    return count < 15; // 通い定員
  }
}

// 泊まりセクション
class TomariSection {
  checkCapacity(date) {
    const count = this.#reservations.filter(r => 
      r.startDate <= date && date <= r.endDate
    ).length;
    return count < 9; // 泊まり定員
  }
}

❌ 間違い
// 通いセクションが泊まりの定員チェックロジックを持つ
class KayoiSection {
  checkAllCapacity(date) {
    const kayoiOK = this.checkCapacity(date);
    const tomariOK = tomariSection.checkCapacity(date); // ❌
    return kayoiOK && tomariOK;
  }
}
```

---

### 2.5 セクション間通信（イベント駆動）

#### ルール

**セクション間の通信はイベント駆動で行う**

```javascript
✅ 正しい
// 通いセクション（送信側）
class KayoiSection {
  addSchedule(date, userId) {
    this.#schedules.push({ date, userId });
    
    // イベントで通知
    this.dispatchEvent(new CustomEvent('kayoi:scheduleAdded', {
      detail: { date, userId }
    }));
  }
}

// 泊まりセクション（受信側・オプション）
class TomariSection {
  constructor() {
    // 必要なら受け取る
    kayoiSection.addEventListener('kayoi:scheduleAdded', (e) => {
      console.log('通いで予定追加:', e.detail);
      // 必要なら何かする（オプション）
    });
  }
}

❌ 間違い
// 直接呼び出し
class KayoiSection {
  addSchedule(date, userId) {
    this.#schedules.push({ date, userId });
    tomariSection.notifyScheduleAdded(date, userId); // ❌ 直接依存
  }
}
```

#### メリット

- **疎結合**: 泊まりセクションが未実装でもエラーにならない
- **テスト容易**: 通いセクション単体でテスト可能
- **拡張性**: 新しいセクションを追加しても既存コードに影響なし

---

### 2.6 共通処理の配置

#### ルール

**セクション間で共通の処理は共通ユーティリティに配置**

```
/src/utils/
  ├─ DateUtils.js      // 日付処理
  ├─ ValidationUtils.js // 共通バリデーション
  ├─ CommonUI.js       // 共通UI部品
  └─ StorageUtils.js   // データ永続化
```

```javascript
✅ 正しい
// DateUtils.js
class DateUtils {
  static parseDate(dateStr) {
    return new Date(dateStr);
  }
  
  static formatDate(date) {
    return date.toISOString().split('T')[0];
  }
  
  static getDayOfWeek(dateStr) {
    const date = new Date(dateStr);
    return date.getDay(); // 0-6
  }
}

// 通いセクションで使用
class KayoiSection {
  isWeekend(date) {
    const dow = DateUtils.getDayOfWeek(date);
    return dow === 0 || dow === 6;
  }
}

// 泊まりセクションでも使用
class TomariSection {
  isWeekend(date) {
    const dow = DateUtils.getDayOfWeek(date);
    return dow === 0 || dow === 6;
  }
}
```

---

## 3. UI/UX規約

### 3.1 アニメーションの原則

#### ルール

**アニメーションは控えめに（0.2秒程度のフェードのみ）**

```css
✅ 正しい
.cell {
  transition: background-color 0.2s ease;
}

.fade-in {
  animation: fadeIn 0.2s ease;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

❌ 間違い
.cell {
  transition: all 1s ease; /* 遅すぎる */
}

.bounce {
  animation: bounce 0.5s infinite; /* 派手すぎる */
}
```

#### 理由

- **業務ツールとしての品位** - ゲームっぽくならない
- **操作を妨げない** - フィードバックは即座に
- **アクセシビリティ** - アニメーションが苦手な人への配慮

**参照**: L1_概要_プロジェクト概要.md の「3.1 基本コンセプト」

---

### 3.2 カーソルの使い分け

#### ルール

**操作可能な要素には適切なカーソルを設定**

```css
✅ 正しい
.cell.editable {
  cursor: pointer;
}

.cell.draggable {
  cursor: grab;
}

.cell.dragging {
  cursor: grabbing;
}

.cell.readonly {
  cursor: default;
}

❌ 間違い
.cell {
  cursor: pointer; /* すべてにpointer → クリックできない要素も含む */
}
```

---

### 3.3 ホバー時の挙動

#### ルール

**ホバー時に視覚的フィードバックを提供**

```css
✅ 正しい
.cell.editable:hover {
  background-color: rgba(0, 123, 255, 0.1);
}

.button:hover {
  opacity: 0.8;
}

❌ 間違い
.cell:hover {
  transform: scale(1.5); /* 派手すぎる */
}
```

---

### 3.4 編集不可の要素

#### ルール

**編集不可の要素は視覚的に区別**

```css
✅ 正しい
.cell.readonly {
  background-color: #f5f5f5;
  color: #999;
  cursor: default;
}

.cell.readonly:hover {
  background-color: #f5f5f5; /* ホバーしても変化なし */
}
```

---

### 3.5 フィードバックの表示

#### ルール

**成功・エラー・情報のフィードバックは控えめに**

```javascript
✅ 正しい
// トースト通知（2秒で自動消去）
function showToast(message, type = 'info') {
  const toast = document.createElement('div');
  toast.className = `toast toast-${type}`;
  toast.textContent = message;
  document.body.appendChild(toast);
  
  setTimeout(() => {
    toast.classList.add('fade-out');
    setTimeout(() => toast.remove(), 200);
  }, 2000);
}

❌ 間違い
// 画面全体を覆うモーダル
function showSuccess(message) {
  const modal = document.createElement('div');
  modal.className = 'modal-overlay'; // 画面全体を覆う
  modal.innerHTML = `<div class="modal">${message}</div>`;
  document.body.appendChild(modal);
  // 閉じるボタンがない...
}
```

**スタイル例**:
```css
.toast {
  position: fixed;
  top: 20px;
  right: 20px;
  padding: 12px 20px;
  border-radius: 4px;
  background-color: #333;
  color: white;
  opacity: 0.9;
  z-index: 1000;
  animation: fadeIn 0.2s ease;
}

.toast.fade-out {
  animation: fadeOut 0.2s ease;
}
```

---

### 3.6 横スクロール禁止（マスト要件）

#### ルール

**すべてのセクションで横スクロールを禁止する**

```css
✅ 正しい
.schedule-grid-container {
  overflow-x: hidden; /* 横スクロール禁止 */
  overflow-y: auto;   /* 縦スクロールのみ */
}

❌ 間違い
.schedule-grid-container {
  overflow-x: auto; /* 横スクロール発生 */
}
```

---

#### レスポンシブ設計

**CSS変数 `clamp()` を使用して画面幅に応じて調整**

```css
:root {
  /* ラベル列は固定 */
  --label-column-width: 80px;
  
  /* 日付セルは画面幅に応じて動的計算 */
  /* 最小35px、最大50px */
  --date-cell-width: clamp(
    35px,
    calc((100vw - 80px - 30px) / 31),
    50px
  );
}
```

**動作**:

| 画面幅 | セル幅 | 備考 |
|--------|--------|------|
| 1920px | 50px（最大） | 1920x1080ノートPC |
| 1440px | 42.9px | Surface Pro（200%スケーリング） |
| 1280px | 38.7px | 小さめのノートPC |
| 1024px | 35px（最小） | 最低限の幅 |

**理由**:

```
画面幅1920pxの場合:
(1920 - 80 - 30) / 31 = 58.7px → 50px（最大幅で制限）

画面幅1440pxの場合（Surface Pro 10）:
(1440 - 80 - 30) / 31 = 42.9px → 42.9px

画面幅1024pxの場合:
(1024 - 80 - 30) / 31 = 29.5px → 35px（最小幅で制限）
```

---

#### 理由

1. **業務要件**
   - L0_業務_調整業務の制約.md 参照
   - 月全体を1画面で俯瞰する必要がある

2. **ユーザビリティ**
   - 横スクロールは操作が煩雑
   - 全体把握が困難

3. **デバイス対応**
   - 1920x1080ノートPC（基準）
   - Surface等の高解像度タブレット
   - DPIスケーリング自動対応

---

#### DPIスケーリングの自動対応

**Webブラウザでは自動処理される**:

```
物理解像度（実際のピクセル数）
  ↓
Windowsスケーリング（125%, 150%, 200%）
  ↓
論理解像度（CSSが見る解像度）← CSS pixelはこれを使用
  ↓
ブラウザ表示
```

**例**:
```
Surface Pro 10: 2880×1920（物理）
スケーリング200% 適用
→ 1440×960（論理）← CSSはこれを見る
→ セル幅: (1440 - 80 - 30) / 31 = 42.9px
```

**重要**: 
- レイアウトは同じサイズ（論理ピクセル）
- 高DPIデバイスでは物理的に高精細に表示される
- ユーザーから見ると「同じ大きさで、きれいに見える」

---

#### 参照

- **L0_業務_調整業務の制約.md**（セクション7: 月別予定表の表示要件）
- **L3_UI_統合UI設計.md**（CSS変数の定義）

---

## 4. エラーハンドリング規約

### 4.1 基本原則

**エラーは早期に検出し、適切に処理する**

```javascript
✅ 正しい
function addSchedule(date, userId) {
  // バリデーション
  if (!date || !userId) {
    throw new Error('日付と利用者IDは必須です');
  }
  
  if (!isValidDate(date)) {
    throw new Error('日付の形式が不正です');
  }
  
  // 処理
  this.#schedules.push({ date, userId });
}

❌ 間違い
function addSchedule(date, userId) {
  // バリデーションなし
  this.#schedules.push({ date, userId }); // 不正なデータが入る可能性
}
```

---

### 4.2 エラーメッセージ

#### ルール

**エラーメッセージは具体的でユーザーフレンドリーに**

```javascript
✅ 正しい
throw new Error('通い定員（15人）を超えています。前半: 16人');

❌ 間違い
throw new Error('エラー'); // 何のエラー？
throw new Error('capacity exceeded'); // 日本語で
```

---

### 4.3 try-catch の使用

#### ルール

**非同期処理・外部データ入力には try-catch を使用**

```javascript
✅ 正しい
async function loadFromStorage() {
  try {
    const data = localStorage.getItem('schedules');
    return JSON.parse(data);
  } catch (error) {
    console.error('データ読み込みエラー:', error);
    return []; // デフォルト値を返す
  }
}

❌ 間違い
async function loadFromStorage() {
  const data = localStorage.getItem('schedules');
  return JSON.parse(data); // エラー時にクラッシュ
}
```

---

## 5. パフォーマンス規約

### 5.1 DOM操作の最小化

#### ルール

**DOM操作は最小限にし、バッチ処理する**

```javascript
✅ 正しい
function renderSchedules(schedules) {
  const fragment = document.createDocumentFragment();
  
  schedules.forEach(schedule => {
    const cell = createCell(schedule);
    fragment.appendChild(cell);
  });
  
  container.appendChild(fragment); // 1回のDOM操作
}

❌ 間違い
function renderSchedules(schedules) {
  schedules.forEach(schedule => {
    const cell = createCell(schedule);
    container.appendChild(cell); // 毎回DOM操作
  });
}
```

---

### 5.2 イベントリスナーの最適化

#### ルール

**イベントデリゲーションを使用**

```javascript
✅ 正しい
// 親要素で一括管理
container.addEventListener('click', (e) => {
  const cell = e.target.closest('.cell');
  if (cell) {
    handleCellClick(cell);
  }
});

❌ 間違い
// 各セルに個別にリスナーを追加
cells.forEach(cell => {
  cell.addEventListener('click', handleCellClick);
});
```

---

## 6. コメント規約

### 6.1 基本原則

**コードが自己説明的であることが理想、必要な場合のみコメント**

```javascript
✅ 正しい
// 通い定員チェック（前半・後半それぞれ15人まで）
function checkKayoiCapacity(date, section) {
  const count = this.getScheduleCount(date, section);
  return count < 15;
}

❌ 間違い
// カウントが15未満かチェックする
function check(d, s) { // 何をチェック？
  const c = this.getCount(d, s);
  return c < 15;
}
```

---

### 6.2 WHYを説明する

#### ルール

**「なぜ」そうするのかを説明、「何を」するのかは説明不要**

```javascript
✅ 正しい
// Date型ではなく文字列を使用する理由：
// - HTMLのdata属性との比較が容易
// - タイムゾーンの問題を回避
const date = "2025-11-23";

❌ 間違い
// dateに文字列を代入
const date = "2025-11-23"; // これは見れば分かる
```

---

### 6.3 TODOコメント

#### ルール

**TODO コメントには担当者と期限を記載**

```javascript
✅ 正しい
// TODO(@tanaka, 2025-12-01): 泊まりセクションと連携する
// - イベントリスナーを追加
// - 定員チェックの統合

❌ 間違い
// TODO: あとで直す
```

---

## 7. localStorage 使用規約

### 7.1 キー名の規約

#### ルール

**キー名はプレフィックス付きで統一**

```javascript
✅ 正しい
const STORAGE_KEYS = {
  KAYOI_SCHEDULES: 'projectB:kayoi:schedules',
  TOMARI_RESERVATIONS: 'projectB:tomari:reservations',
  HOMON_VISITS: 'projectB:homon:visits',
  USER_SETTINGS: 'projectB:settings'
};

❌ 間違い
localStorage.setItem('schedules', data); // プレフィックスなし
```

#### 理由

- **名前空間の分離** - 他のアプリとの衝突を避ける
- **管理の容易さ** - プロジェクトBのデータを一括で確認・削除可能

---

### 7.2 データの保存形式

#### ルール

**JSON形式で保存、バージョン情報を含める**

```javascript
✅ 正しい
const data = {
  version: '1.0',
  timestamp: new Date().toISOString(),
  schedules: [...]
};
localStorage.setItem(key, JSON.stringify(data));

❌ 間違い
localStorage.setItem(key, JSON.stringify([...])); // バージョンなし
```

---


### 7.3 StorageUtils使用規約（v1.2 更新）

#### ルール

**localStorage への直接アクセスは禁止、StorageUtilsを経由する**

```javascript
✅ 正しい
const users = StorageUtils.load('users', []);
StorageUtils.save('users', users);

❌ 間違い
const users = JSON.parse(localStorage.getItem('projectB_users'));
localStorage.setItem('projectB_users', JSON.stringify(users));
```

#### 理由

- **キー管理の一元化**（PREFIX: `projectB_`）
- **エラーハンドリングの統一**
- **データマイグレーションの透過的実行**

#### 詳細仕様

**StorageUtilsクラスの詳細実装仕様は以下を参照**:
- **L2_共通_StorageUtils設計.md** - 完全な実装仕様

**実装時の注意**:
- メソッド呼び出し時は**PREFIXなしのキー**を指定
- `save('users', data)` → `localStorage['projectB_users']`
- `load('users')` → `localStorage['projectB_users']`

---

### 7.4 データマイグレーション（v1.2 更新）

#### 概要

アプリ起動時に旧データ（`users`）を新キー（`projectB_users`）に自動移行します。

#### 呼び出し方法

```javascript
// main.js の init() で最初に呼び出す
class App {
  async init() {
    console.log('Application initializing...');
    
    // データ移行を最初に実行
    const migrationResult = StorageUtils.migrate();
    
    if (migrationResult.migrated && migrationResult.keys.length > 0) {
      console.log('📝 旧データを移行しました:', migrationResult.keys);
    }
    
    // マスターデータ初期化
    this.masterData = new MasterDataManager();
    
    // ... 以下既存のコード
  }
}
```

#### 重要な仕様

- **冪等性**: 何度実行しても結果が同じ
- **安全性**: 既存データを上書きしない
- **透過的**: ユーザーは移行を意識しない

#### 詳細仕様

**マイグレーション機能の詳細は以下を参照**:
- **L2_共通_StorageUtils設計.md** セクション2 - マイグレーション機能

---

## 8. まとめ

### 8.1 最重要ルール（再掲）

```
1. 日付は文字列（"YYYY-MM-DD"）
2. IDは文字列
3. セクションは独立（直接依存しない）
4. イベント駆動で通信
5. アニメーションは控えめ（0.2秒）
6. エラーは早期検出
7. DOM操作は最小化
8. 🆕 localStorage はStorageUtilsを経由（v1.2追加）
9. 🆕 データマイグレーションは起動時に自動実行（v1.2追加）
```

---

### 8.2 このドキュメントで決めたこと

```
✅ 決めたこと（v1.2）
├─ データ型規約（日付、ID、数値、null/undefined）
├─ セクション独立性の実装方法
├─ UI/UX規約（アニメーション、カーソル、フィードバック）
├─ エラーハンドリングの方針
├─ パフォーマンス規約
├─ コメント規約
├─ localStorage使用規約（キー名、保存形式）
└─ 🆕 StorageUtils使用規約・マイグレーション規約（v1.2追加）
```

**注**: StorageUtilsの詳細実装仕様はL2_共通_StorageUtils設計.mdに分離

---

### 8.3 このドキュメントで決めなかったこと

```
❌ 決めなかったこと（L2層で定義）
├─ 利用者マスタの詳細プロパティ
├─ 各セクション固有のデータ構造
├─ UI の具体的なレイアウト
├─ ビジネスロジックの詳細
├─ 関数名・変数名
└─ 🆕 StorageUtilsの詳細実装（L2_共通_StorageUtils設計.mdに分離）
```

---

### 8.4 v1.2での変更内容

```
🆕 v1.2で変更
├─ セクション7.3: StorageUtils使用規約を追加
│   └─ 詳細はL2_共通_StorageUtils設計.mdに分離
│
├─ セクション7.4: データマイグレーション規約を追加
│   └─ 詳細はL2_共通_StorageUtils設計.mdに分離
│
└─ 設計原則: 「実装制約」は最小限のルールのみ
    詳細仕様はL2層に分離することを明確化
```

**設計判断の背景**:
- L1（実装制約）: 最小限のルール = 「何を守るべきか」
- L2（詳細仕様）: 完全な実装コード = 「どう実装するか」
- この分離により、L1はシンプルに保たれる

---

### 8.5 次のステップ

このドキュメントで最小限のルールを確立しました。

**次に作成すべきドキュメント**:
1. **L2_通い_データ構造.md** - 通いセクションの詳細設計
2. **L2_泊まり_データ構造.md** - 泊まりセクションの詳細設計
3. **L2_訪問_データ構造.md** - 訪問セクションの詳細設計

**その後**:
4. **L1_データ_共通データ構造.md** - 3セクションから共通部分を抽出

---

## 📚 次に読むべきドキュメント

このドキュメントを読了したら、以下のドキュメントに進んでください。

### 次のドキュメント

**L2_通い_データ構造.md**
- 通いセクションの予定データ
- 前半・後半の管理
- 定員チェックのロジック

---

## 📝 参考資料

- L1_概要_プロジェクト概要.md（セクション独立性の原則）
- CHECKLIST_設計レビュー.md（前プロジェクトの教訓）
- TEMPLATE_L2_データ構造.md（型変換の責任）
- 🆕 L2_共通_StorageUtils設計.md（StorageUtils詳細仕様）

---

## 📅 更新履歴

| 日付 | バージョン | 変更内容 | 担当 |
|------|----------|---------|------|
| 2025-11-23 | 1.0 | 初版作成 | Claude |
| 2026-01-03 | 1.2 | StorageUtils使用規約追加、詳細をL2に分離 | Claude |

---

**最終更新**: 2026年01月03日  
**次回更新予定**: Phase 1実装中のフィードバック反映時

---

## 💡 このドキュメントの活用方法

### 実装時

- **データ型の確認**: 日付は文字列、IDは文字列
- **セクション設計の確認**: 直接依存していないか？
- **エラーハンドリングの確認**: try-catchは適切か？
- **🆕 Storage使用の確認**: StorageUtilsを経由しているか？

### コードレビュー時

- **型の統一**: 日付がDate型になっていないか？
- **セクション独立性**: 他セクションに直接アクセスしていないか？
- **パフォーマンス**: DOM操作は最小化されているか？
- **🆕 localStorage直接アクセス**: 禁止されているパターンがないか？

### テスト時

- **型チェック**: 文字列で保存されているか？
- **エラーケース**: 不正な入力でエラーが出るか？
- **イベント通信**: セクション間の通信は正しく動作するか？
- **🆕 マイグレーション**: 旧データが正しく移行されるか？

---

**このドキュメントを読了したら、INDEX_ドキュメント構成.md に戻り、次のドキュメントに進んでください。**