# L1_データ_共通データ構造

**作成日**: 2025年11月23日  
**カテゴリ**: 第1層 - プロジェクト共通  
**バージョン**: 1.0

---

## 📖 このドキュメントについて

このドキュメントは、**通い・泊まり・訪問の3セクションで共通して使用するデータ構造**を定義します。

### 対象読者

- 全セクションの実装担当者
- データベース設計担当者
- テスト担当者

### 読了後に理解できること

- 利用者マスタの構造
- 職員マスタの構造
- 居室マスタの構造
- 移動時間マトリックスの構造
- 祝日カレンダーの構造
- データの参照方法と更新タイミング

### 設計の前提

- **L1_技術_実装制約.md** の技術規約に準拠
- **L0_業務_小規模多機能とは.md** の業務知識に基づく
- Phase 1ではlocalStorageで管理、Phase 2以降でサーバー連携

---

## 1. 共通データ構造の概要

### 1.1 共通データの種類

```
共通データ（マスタデータ）
├─ User（利用者マスタ）
├─ Staff（職員マスタ）
├─ Room（居室マスタ）
├─ TravelTimeMatrix（移動時間マトリックス）
└─ HolidayCalendar（祝日カレンダー）
```

---

### 1.2 データの特性

| データ | 更新頻度 | 参照頻度 | Phase 1の保存先 |
|-------|---------|---------|----------------|
| **User** | 低（月数回） | 高 | localStorage |
| **Staff** | 低（月数回） | 高 | localStorage |
| **Room** | 低（年数回） | 高 | localStorage |
| **TravelTimeMatrix** | 低（年数回） | 中 | localStorage |
| **HolidayCalendar** | 低（年1回） | 高 | localStorage |

**重要**: すべてマスタデータであり、トランザクションデータ（予定データ）とは分離して管理します。

---

### 1.3 データの責任分担

```
共通データの管理
├─ 作成・更新 → 管理画面（Phase 2以降）
├─ 読み込み → 各セクション
├─ キャッシュ → 各セクションがローカルにキャッシュ
└─ 同期 → アプリ起動時、データ変更時
```

---

## 2. User（利用者マスタ）

### 2.1 責務

**利用者マスタ**は、小規模多機能型居宅介護に**登録している利用者**の基本情報を管理します。

---

### 2.2 データ構造

#### プロパティ

| プロパティ名 | 型 | 必須 | デフォルト値 | 説明 |
|------------|----|----|----------|------|
| **userId** | `string` | ✓ | - | 利用者ID（例: `"user001"`） |
| **name** | `string` | ✓ | - | 利用者名（例: `"山田太郎"`） |
| **kana** | `string` | ✓ | - | フリガナ（例: `"ヤマダタロウ"`） |
| **displayName** | `string` | - | `name` | 表示用名前（例: `"山田"`、姓のみなど） |
| **gender** | `"male"` \| `"female"` \| `"other"` | - | `null` | 性別 |
| **birthDate** | `string` | - | `null` | 生年月日（`"YYYY-MM-DD"`） |
| **careLevel** | `number` | - | `null` | 要介護度（1～5、0は要支援） |
| **address** | `string` | - | `null` | 住所 |
| **latitude** | `number` | - | `null` | 緯度（移動時間計算用） |
| **longitude** | `number` | - | `null` | 経度（移動時間計算用） |
| **phoneNumber** | `string` | - | `null` | 電話番号 |
| **emergencyContact** | `string` | - | `null` | 緊急連絡先 |
| **notes** | `string` | - | `""` | 備考（特記事項） |
| **weeklyPattern** | `Object` | - | `null` | 週間利用パターン（算定基礎CSVから取り込み） |
| **isActive** | `boolean` | ✓ | `true` | 利用中かどうか |
| **registeredAt** | `string` | ✓ | 自動生成 | 登録日時（ISO形式） |
| **updatedAt** | `string` | ✓ | 自動生成 | 更新日時（ISO形式） |

---

#### weeklyPattern（週間利用パターン）の構造

算定基礎CSVから取り込んだ週間パターンを保持します。

```typescript
interface WeeklyPattern {
  dayPattern: string[];    // 通い: 月〜日の7要素 ['1', '-', '1', '-', '1', '-', '-']
  visitPattern: string[];  // 訪問: 月〜日の7要素 ['1', '0', '2', '1', '0', '0', '0']
  stayPattern: string[];   // 泊まり: 月〜日の7要素 ['-', '-', '-', '-', '1', '1', '1']
}
```

**値の意味**:
- `dayPattern`: `'1'` = 利用あり、`'-'` = 利用なし
- `visitPattern`: `'0'`〜`'9'` = 訪問回数、`'-'` = 訪問なし
- `stayPattern`: `'1'` = 宿泊あり、`'-'` = 宿泊なし

**例**: 月水金に通い、火木土日に訪問（各1回）、金土日に泊まり

```javascript
{
  dayPattern: ['1', '-', '1', '-', '1', '-', '-'],
  visitPattern: ['-', '1', '-', '1', '-', '1', '1'],
  stayPattern: ['-', '-', '-', '-', '1', '1', '1']
}
```

---

#### Phase 1の必須プロパティ

Phase 1では、以下のプロパティのみ実装します：

```javascript
// Phase 1で必須
{
  userId: "user001",
  name: "山田太郎",
  kana: "ヤマダタロウ",
  displayName: "山田",  // デフォルトはnameから自動生成
  isActive: true,
  registeredAt: "2025-11-23T00:00:00.000Z",
  updatedAt: "2025-11-23T00:00:00.000Z"
}
```

**Phase 2以降で追加**:
- gender, birthDate, careLevel（AI連携用）
- address, latitude, longitude（移動時間計算用）
- phoneNumber, emergencyContact（緊急時対応）

---

### 2.3 User クラスの実装例

```javascript
class User {
  constructor(data) {
    // 必須
    this.userId = data.userId;
    this.name = data.name;
    this.kana = data.kana;
    this.displayName = data.displayName || this.extractDisplayName(data.name);
    this.isActive = data.isActive !== undefined ? data.isActive : true;
    this.registeredAt = data.registeredAt || new Date().toISOString();
    this.updatedAt = data.updatedAt || new Date().toISOString();
    
    // 任意（Phase 2以降）
    this.gender = data.gender || null;
    this.birthDate = data.birthDate || null;
    this.careLevel = data.careLevel || null;
    this.address = data.address || null;
    this.latitude = data.latitude || null;
    this.longitude = data.longitude || null;
    this.phoneNumber = data.phoneNumber || null;
    this.emergencyContact = data.emergencyContact || null;
    this.notes = data.notes || "";
    this.weeklyPattern = data.weeklyPattern || null;  // 週間パターン
  }
  
  /**
   * 表示用名前を自動生成（姓のみ抽出）
   */
  extractDisplayName(fullName) {
    // "山田太郎" → "山田"
    // スペースがあれば前半を、なければ最初の2文字を取得
    if (fullName.includes(' ')) {
      return fullName.split(' ')[0];
    }
    if (fullName.includes('　')) {  // 全角スペース
      return fullName.split('　')[0];
    }
    return fullName.slice(0, 2);  // 最初の2文字
  }
  
  /**
   * バリデーション
   */
  validate() {
    const errors = [];
    
    if (!this.userId) {
      errors.push('利用者IDは必須です');
    }
    if (!this.name) {
      errors.push('利用者名は必須です');
    }
    if (!this.kana) {
      errors.push('フリガナは必須です');
    }
    
    // フリガナの形式チェック（カタカナのみ）
    if (this.kana && !/^[ァ-ヶー]+$/.test(this.kana)) {
      errors.push('フリガナはカタカナで入力してください');
    }
    
    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined
    };
  }
  
  /**
   * JSON変換
   */
  toJSON() {
    return {
      userId: this.userId,
      name: this.name,
      kana: this.kana,
      displayName: this.displayName,
      gender: this.gender,
      birthDate: this.birthDate,
      careLevel: this.careLevel,
      address: this.address,
      latitude: this.latitude,
      longitude: this.longitude,
      phoneNumber: this.phoneNumber,
      emergencyContact: this.emergencyContact,
      notes: this.notes,
      isActive: this.isActive,
      registeredAt: this.registeredAt,
      updatedAt: this.updatedAt
    };
  }
  
  /**
   * JSONからインスタンス生成
   */
  static fromJSON(json) {
    return new User(json);
  }
}
```

---

### 2.4 利用者マスタの管理

#### 登録定員の制限

**小規模多機能型居宅介護の登録定員**: **29人以下**

```javascript
const MAX_REGISTERED_USERS = 29;

function canAddUser(users) {
  const activeUsers = users.filter(u => u.isActive);
  return activeUsers.length < MAX_REGISTERED_USERS;
}
```

**重要**: 退所した利用者（`isActive: false`）は登録定員にカウントしない

---

#### 利用者の状態遷移

```
[未登録]
   ↓ 新規登録
[登録中（isActive: true）]
   ↓ 退所処理
[退所済（isActive: false）]
```

**注意**: 退所した利用者のデータは削除せず、`isActive: false`にする（履歴保持のため）

---

### 2.5 データの永続化

#### Phase 1（localStorage）

```javascript
// 保存
function saveUsers(users) {
  const data = {
    version: '1.0',
    savedAt: new Date().toISOString(),
    users: users.map(u => u.toJSON())
  };
  localStorage.setItem('projectB:users', JSON.stringify(data));
}

// 読み込み
function loadUsers() {
  try {
    const json = localStorage.getItem('projectB:users');
    if (!json) return [];
    
    const data = JSON.parse(json);
    return data.users.map(u => User.fromJSON(u));
  } catch (error) {
    console.error('利用者マスタ読み込みエラー:', error);
    return [];
  }
}
```

---

## 3. Staff（職員マスタ）

### 3.1 責務

**職員マスタ**は、小規模多機能型居宅介護で働く職員の基本情報を管理します。

**Phase 1での用途**: 訪問予定の担当者として参照（割り当ては任意）

---

### 3.2 データ構造

#### プロパティ

| プロパティ名 | 型 | 必須 | デフォルト値 | 説明 |
|------------|----|----|----------|------|
| **staffId** | `string` | ✓ | - | 職員ID（例: `"staff001"`） |
| **name** | `string` | ✓ | - | 職員名（例: `"佐藤花子"`） |
| **kana** | `string` | ✓ | - | フリガナ（例: `"サトウハナコ"`） |
| **displayName** | `string` | - | `name` | 表示用名前（例: `"佐藤"`） |
| **role** | `string` | - | `"staff"` | 役割（例: `"管理者"`, `"介護職員"`, `"看護師"`） |
| **isActive** | `boolean` | ✓ | `true` | 勤務中かどうか |
| **createdAt** | `string` | ✓ | 自動生成 | 作成日時（ISO形式） |
| **updatedAt** | `string` | ✓ | 自動生成 | 更新日時（ISO形式） |

---

#### Phase 1の必須プロパティ

```javascript
// Phase 1で必須
{
  staffId: "staff001",
  name: "佐藤花子",
  kana: "サトウハナコ",
  displayName: "佐藤",
  isActive: true,
  createdAt: "2025-11-23T00:00:00.000Z",
  updatedAt: "2025-11-23T00:00:00.000Z"
}
```

**Phase 2以降で追加**:
- workSchedule（勤務シフト）
- skills（スキル・資格）
- maxVisitsPerDay（1日あたりの訪問可能件数）

---

### 3.3 Staff クラスの実装例

```javascript
class Staff {
  constructor(data) {
    this.staffId = data.staffId;
    this.name = data.name;
    this.kana = data.kana;
    this.displayName = data.displayName || this.extractDisplayName(data.name);
    this.role = data.role || "staff";
    this.isActive = data.isActive !== undefined ? data.isActive : true;
    this.createdAt = data.createdAt || new Date().toISOString();
    this.updatedAt = data.updatedAt || new Date().toISOString();
  }
  
  extractDisplayName(fullName) {
    if (fullName.includes(' ')) {
      return fullName.split(' ')[0];
    }
    if (fullName.includes('　')) {
      return fullName.split('　')[0];
    }
    return fullName.slice(0, 2);
  }
  
  validate() {
    const errors = [];
    
    if (!this.staffId) {
      errors.push('職員IDは必須です');
    }
    if (!this.name) {
      errors.push('職員名は必須です');
    }
    if (!this.kana) {
      errors.push('フリガナは必須です');
    }
    
    if (this.kana && !/^[ァ-ヶー]+$/.test(this.kana)) {
      errors.push('フリガナはカタカナで入力してください');
    }
    
    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined
    };
  }
  
  toJSON() {
    return {
      staffId: this.staffId,
      name: this.name,
      kana: this.kana,
      displayName: this.displayName,
      role: this.role,
      isActive: this.isActive,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt
    };
  }
  
  static fromJSON(json) {
    return new Staff(json);
  }
}
```

---

### 3.4 データの永続化

```javascript
// 保存
function saveStaff(staff) {
  const data = {
    version: '1.0',
    savedAt: new Date().toISOString(),
    staff: staff.map(s => s.toJSON())
  };
  localStorage.setItem('projectB:staff', JSON.stringify(data));
}

// 読み込み
function loadStaff() {
  try {
    const json = localStorage.getItem('projectB:staff');
    if (!json) return [];
    
    const data = JSON.parse(json);
    return data.staff.map(s => Staff.fromJSON(s));
  } catch (error) {
    console.error('職員マスタ読み込みエラー:', error);
    return [];
  }
}
```

---

## 4. Room（居室マスタ）

### 4.1 責務

**居室マスタ**は、泊まりサービスで使用する居室の情報を管理します。

---

### 4.2 データ構造

#### プロパティ

| プロパティ名 | 型 | 必須 | デフォルト値 | 説明 |
|------------|----|----|----------|------|
| **roomId** | `string` | ✓ | - | 居室ID（例: `"room01"`） |
| **name** | `string` | ✓ | - | 居室名（例: `"1号室"`） |
| **displayOrder** | `number` | - | `0` | 表示順序（グリッド表示時の並び順） |
| **isActive** | `boolean` | ✓ | `true` | 使用可/不可（メンテナンス中などで一時的に使えない） |
| **createdAt** | `string` | ✓ | 自動生成 | 作成日時（ISO形式） |
| **updatedAt** | `string` | ✓ | 自動生成 | 更新日時（ISO形式） |

---

#### Phase 1の必須プロパティ

```javascript
// Phase 1で必須
{
  roomId: "room01",
  name: "1号室",
  displayOrder: 1,
  isActive: true,
  createdAt: "2025-11-23T00:00:00.000Z",
  updatedAt: "2025-11-23T00:00:00.000Z"
}
```

**Phase 2以降で追加**（AI連携用）:
- floor（階数）
- nearNurseStation（ナースステーションに近いか）
- equipment（設備: 介護ベッド、トイレ等）
- size（広さ: ㎡）

---

### 4.3 Room クラスの実装例

```javascript
class Room {
  constructor(data) {
    this.roomId = data.roomId;
    this.name = data.name;
    this.displayOrder = data.displayOrder || 0;
    this.isActive = data.isActive !== undefined ? data.isActive : true;
    this.createdAt = data.createdAt || new Date().toISOString();
    this.updatedAt = data.updatedAt || new Date().toISOString();
  }
  
  validate() {
    const errors = [];
    
    if (!this.roomId) {
      errors.push('居室IDは必須です');
    }
    if (!this.name) {
      errors.push('居室名は必須です');
    }
    
    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined
    };
  }
  
  toJSON() {
    return {
      roomId: this.roomId,
      name: this.name,
      displayOrder: this.displayOrder,
      isActive: this.isActive,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt
    };
  }
  
  static fromJSON(json) {
    return new Room(json);
  }
}
```

---

### 4.4 居室数の制限

**泊まり定員**: **9人/日**

```javascript
const MAX_ROOMS = 9;

// 通常は居室数 = 泊まり定員
function getRooms() {
  return [
    new Room({ roomId: "room01", name: "1号室", displayOrder: 1 }),
    new Room({ roomId: "room02", name: "2号室", displayOrder: 2 }),
    new Room({ roomId: "room03", name: "3号室", displayOrder: 3 }),
    new Room({ roomId: "room04", name: "4号室", displayOrder: 4 }),
    new Room({ roomId: "room05", name: "5号室", displayOrder: 5 }),
    new Room({ roomId: "room06", name: "6号室", displayOrder: 6 }),
    new Room({ roomId: "room07", name: "7号室", displayOrder: 7 }),
    new Room({ roomId: "room08", name: "8号室", displayOrder: 8 }),
    new Room({ roomId: "room09", name: "9号室", displayOrder: 9 })
  ];
}
```

---

### 4.5 データの永続化

```javascript
// 保存
function saveRooms(rooms) {
  const data = {
    version: '1.0',
    savedAt: new Date().toISOString(),
    rooms: rooms.map(r => r.toJSON())
  };
  localStorage.setItem('projectB:rooms', JSON.stringify(data));
}

// 読み込み
function loadRooms() {
  try {
    const json = localStorage.getItem('projectB:rooms');
    if (!json) {
      // デフォルトの9部屋を返す
      return getRooms();
    }
    
    const data = JSON.parse(json);
    return data.rooms.map(r => Room.fromJSON(r));
  } catch (error) {
    console.error('居室マスタ読み込みエラー:', error);
    return getRooms();
  }
}
```

---

## 5. TravelTimeMatrix（移動時間マトリックス）

### 5.1 責務

**移動時間マトリックス**は、訪問サービスにおいて、**利用者宅間の移動時間**を管理します。

**用途**: 訪問予定の時間帯が詰まりすぎていないかをチェックする際に参照

---

### 5.2 データ構造

#### 形式

```javascript
// 移動時間マトリックス（分単位）
{
  // 施設 → 各利用者宅
  "facility": {
    "user001": 10,
    "user002": 15,
    "user003": 20
  },
  
  // 利用者宅 → 利用者宅
  "user001": {
    "user002": 5,
    "user003": 10,
    "facility": 10
  },
  
  "user002": {
    "user001": 5,
    "user003": 8,
    "facility": 15
  },
  
  "user003": {
    "user001": 10,
    "user002": 8,
    "facility": 20
  }
}
```

---

#### 移動時間の取得方法

```javascript
/**
 * 移動時間を取得
 * @param {Object} matrix - 移動時間マトリックス
 * @param {string} fromId - 出発地ID（"facility" または userId）
 * @param {string} toId - 目的地ID（"facility" または userId）
 * @returns {number} 移動時間（分）、データがない場合はデフォルト値
 */
function getTravelTime(matrix, fromId, toId) {
  // 同じ場所の場合は0分
  if (fromId === toId) {
    return 0;
  }
  
  // マトリックスから取得
  if (matrix[fromId] && matrix[fromId][toId] !== undefined) {
    return matrix[fromId][toId];
  }
  
  // データがない場合はデフォルト値（20分）
  return 20;
}
```

---

### 5.3 Phase 1の実装

#### 5.3.1 簡略化したマトリックス

Phase 1では、すべての移動時間を**一律20分**として扱います。

```javascript
/**
 * Phase 1: 簡略版
 */
function getTravelTimeSimple(fromId, toId) {
  if (fromId === toId) {
    return 0;
  }
  return 20; // すべて20分
}
```

---

#### 5.3.2 Phase 2以降での拡張

Phase 2以降では、以下の方法で移動時間を計算します：

**方法1: 管理画面での手動入力**
```javascript
// 管理画面で個別に設定
{
  "user001": { "user002": 5 },  // 山田さん → 田中さん: 5分
  "user002": { "user003": 10 }  // 田中さん → 佐藤さん: 10分
}
```

**方法2: 緯度経度からの自動計算**
```javascript
// 利用者マスタの緯度経度から距離を計算
// 距離 ÷ 時速30km = 移動時間
function calculateTravelTime(user1, user2) {
  const distance = getDistance(
    user1.latitude, user1.longitude,
    user2.latitude, user2.longitude
  );
  
  // 時速30km（0.5km/分）で計算
  const minutes = Math.ceil(distance / 0.5);
  
  return minutes;
}
```

---

### 5.4 データの永続化

```javascript
// 保存
function saveTravelTimeMatrix(matrix) {
  const data = {
    version: '1.0',
    savedAt: new Date().toISOString(),
    matrix: matrix
  };
  localStorage.setItem('projectB:travelTimeMatrix', JSON.stringify(data));
}

// 読み込み
function loadTravelTimeMatrix() {
  try {
    const json = localStorage.getItem('projectB:travelTimeMatrix');
    if (!json) {
      return {}; // 空のマトリックス（Phase 1ではデフォルト20分を使用）
    }
    
    const data = JSON.parse(json);
    return data.matrix;
  } catch (error) {
    console.error('移動時間マトリックス読み込みエラー:', error);
    return {};
  }
}
```

---

## 6. HolidayCalendar（祝日カレンダー）

### 6.1 責務

**祝日カレンダー**は、日本の祝日情報を管理します。

**用途**: 
- カレンダー表示時に祝日を色分け
- 曜日による定員の調整（Phase 2以降）

---

### 6.2 データ構造

#### 形式

```javascript
// 祝日カレンダー（日付 → 祝日名）
{
  "2025-01-01": "元日",
  "2025-01-13": "成人の日",
  "2025-02-11": "建国記念の日",
  "2025-02-23": "天皇誕生日",
  "2025-02-24": "振替休日",
  "2025-03-20": "春分の日",
  "2025-04-29": "昭和の日",
  "2025-05-03": "憲法記念日",
  "2025-05-04": "みどりの日",
  "2025-05-05": "こどもの日",
  "2025-05-06": "振替休日",
  "2025-07-21": "海の日",
  "2025-08-11": "山の日",
  "2025-09-15": "敬老の日",
  "2025-09-23": "秋分の日",
  "2025-10-13": "スポーツの日",
  "2025-11-03": "文化の日",
  "2025-11-23": "勤労感謝の日",
  "2025-11-24": "振替休日"
}
```

---

### 6.3 祝日の判定

```javascript
/**
 * 祝日かどうか判定
 * @param {Object} calendar - 祝日カレンダー
 * @param {string} date - 日付（"YYYY-MM-DD"）
 * @returns {boolean} 祝日ならtrue
 */
function isHoliday(calendar, date) {
  return calendar[date] !== undefined;
}

/**
 * 祝日名を取得
 * @param {Object} calendar - 祝日カレンダー
 * @param {string} date - 日付（"YYYY-MM-DD"）
 * @returns {string|null} 祝日名、祝日でなければnull
 */
function getHolidayName(calendar, date) {
  return calendar[date] || null;
}
```

---

### 6.4 Phase 1の実装

#### 固定データとして埋め込み

Phase 1では、2025年の祝日を固定データとして実装します。

```javascript
// Phase 1: 2025年の祝日（固定）
const HOLIDAYS_2025 = {
  "2025-01-01": "元日",
  "2025-01-13": "成人の日",
  "2025-02-11": "建国記念の日",
  "2025-02-23": "天皇誕生日",
  "2025-02-24": "振替休日",
  "2025-03-20": "春分の日",
  "2025-04-29": "昭和の日",
  "2025-05-03": "憲法記念日",
  "2025-05-04": "みどりの日",
  "2025-05-05": "こどもの日",
  "2025-05-06": "振替休日",
  "2025-07-21": "海の日",
  "2025-08-11": "山の日",
  "2025-09-15": "敬老の日",
  "2025-09-23": "秋分の日",
  "2025-10-13": "スポーツの日",
  "2025-11-03": "文化の日",
  "2025-11-23": "勤労感謝の日",
  "2025-11-24": "振替休日"
};

function getHolidayCalendar(year) {
  if (year === 2025) {
    return HOLIDAYS_2025;
  }
  // Phase 2以降: API等から取得
  return {};
}
```

---

### 6.5 データの永続化

```javascript
// 保存
function saveHolidayCalendar(calendar) {
  const data = {
    version: '1.0',
    savedAt: new Date().toISOString(),
    calendar: calendar
  };
  localStorage.setItem('projectB:holidayCalendar', JSON.stringify(data));
}

// 読み込み
function loadHolidayCalendar() {
  try {
    const json = localStorage.getItem('projectB:holidayCalendar');
    if (!json) {
      // Phase 1: 2025年の祝日を返す
      return HOLIDAYS_2025;
    }
    
    const data = JSON.parse(json);
    return data.calendar;
  } catch (error) {
    console.error('祝日カレンダー読み込みエラー:', error);
    return HOLIDAYS_2025;
  }
}
```

---

## 7. 共通データの管理

### 7.1 データ管理クラス

```javascript
class MasterDataManager {
  constructor() {
    this.users = [];
    this.staff = [];
    this.rooms = [];
    this.travelTimeMatrix = {};
    this.holidayCalendar = {};
  }
  
  /**
   * 初期化（アプリ起動時に呼ぶ）
   */
  async initialize() {
    try {
      this.users = loadUsers();
      this.staff = loadStaff();
      this.rooms = loadRooms();
      this.travelTimeMatrix = loadTravelTimeMatrix();
      this.holidayCalendar = loadHolidayCalendar();
      
      console.log('マスタデータを読み込みました');
      console.log('- 利用者:', this.users.length, '件');
      console.log('- 職員:', this.staff.length, '件');
      console.log('- 居室:', this.rooms.length, '件');
    } catch (error) {
      console.error('マスタデータ初期化エラー:', error);
      throw error;
    }
  }
  
  /**
   * 利用者を取得
   */
  getUser(userId) {
    return this.users.find(u => u.userId === userId);
  }
  
  /**
   * 有効な利用者のみ取得
   */
  getActiveUsers() {
    return this.users.filter(u => u.isActive);
  }
  
  /**
   * 職員を取得
   */
  getStaff(staffId) {
    return this.staff.find(s => s.staffId === staffId);
  }
  
  /**
   * 有効な職員のみ取得
   */
  getActiveStaff() {
    return this.staff.filter(s => s.isActive);
  }
  
  /**
   * 居室を取得
   */
  getRoom(roomId) {
    return this.rooms.find(r => r.roomId === roomId);
  }
  
  /**
   * 有効な居室のみ取得
   */
  getActiveRooms() {
    return this.rooms.filter(r => r.isActive);
  }
  
  /**
   * 移動時間を取得
   */
  getTravelTime(fromId, toId) {
    return getTravelTime(this.travelTimeMatrix, fromId, toId);
  }
  
  /**
   * 祝日かどうか判定
   */
  isHoliday(date) {
    return isHoliday(this.holidayCalendar, date);
  }
  
  /**
   * 祝日名を取得
   */
  getHolidayName(date) {
    return getHolidayName(this.holidayCalendar, date);
  }
}

// グローバルインスタンス
const masterData = new MasterDataManager();
```

---

### 7.2 初期化フロー

```javascript
// アプリ起動時
document.addEventListener('DOMContentLoaded', async () => {
  try {
    // マスタデータの初期化
    await masterData.initialize();
    
    // 各セクションの初期化
    initializeKayoiSection();
    initializeTomariSection();
    initializeHoumonSection();
    
    console.log('アプリの初期化が完了しました');
  } catch (error) {
    console.error('初期化エラー:', error);
    alert('データの読み込みに失敗しました。ページを再読み込みしてください。');
  }
});
```

---

## 8. データの同期戦略

### 8.1 Phase 1（localStorage）

```
データの流れ（Phase 1）
  ↓ アプリ起動時
[localStorage] → [MasterDataManager] → [各セクション]
  ↑ データ更新時
[管理画面] → [MasterDataManager] → [localStorage]
```

**重要**: Phase 1では、マスタデータの更新は管理画面からのみ行う

---

### 8.2 Phase 2（サーバー連携）

```
データの流れ（Phase 2）
  ↓ アプリ起動時
[サーバー] → [MasterDataManager] → [各セクション]
  ↑ データ更新時
[管理画面] → [サーバー] → [MasterDataManager] → [各セクション]
```

**追加機能**:
- 定期的な同期（5分ごとなど）
- 他のユーザーによる更新の検知
- 競合解決

---

## 9. まとめ

### 9.1 このドキュメントで定義したこと

```
✅ 定義したこと
├─ User（利用者マスタ）の構造
├─ Staff（職員マスタ）の構造
├─ Room（居室マスタ）の構造
├─ TravelTimeMatrix（移動時間マトリックス）の構造
├─ HolidayCalendar（祝日カレンダー）の構造
├─ MasterDataManagerクラスの設計
├─ データの永続化方法（localStorage）
└─ データの同期戦略
```

---

### 9.2 重要なポイント

1. **マスタデータとトランザクションデータの分離**: 予定データとは別管理
2. **Phase分け**: Phase 1は最小限の実装、Phase 2で拡張
3. **デフォルト値**: データがない場合の振る舞いを定義
4. **isActiveフラグ**: 削除ではなく、無効化で履歴保持
5. **MasterDataManager**: 各セクションから共通アクセス

---

### 9.3 Phase 1で実装すること

```
✅ Phase 1
├─ User（userId, name, kana, displayName, isActive）
├─ Staff（staffId, name, kana, displayName, isActive）
├─ Room（roomId, name, displayOrder, isActive）
├─ TravelTimeMatrix（一律20分）
├─ HolidayCalendar（2025年固定）
└─ MasterDataManager（基本機能）

⏭️ Phase 2以降
├─ User拡張（緯度経度、要介護度等）
├─ Staff拡張（勤務シフト、スキル等）
├─ Room拡張（設備情報、AI連携用）
├─ TravelTimeMatrix（自動計算）
├─ HolidayCalendar（API連携）
└─ サーバー同期
```

---

### 9.4 次のステップ

共通データ構造が定義できたので、次は各セクションの設計に進みます：

**既存のドキュメント**:
- L2_通い_データ構造.md ✅
- L2_泊まり_データ構造.md ✅
- L2_訪問_データ構造.md ✅

**次に作成すべきドキュメント**:
- L3_UI_統合UI設計.md - 3セクションの統合UI
- L3_データ_統合データ管理.md - セクション間のデータ連携

---

## 📚 次に読むべきドキュメント

このドキュメントを読了したら、以下のドキュメントに進んでください。

### 関連ドキュメント

- **L2_通い_データ構造.md** - User, Staffの参照方法
- **L2_泊まり_データ構造.md** - User, Roomの参照方法
- **L2_訪問_データ構造.md** - User, Staff, TravelTimeMatrixの参照方法
- **L1_技術_実装制約.md** - データ型規約、永続化戦略

---

## 📝 参考資料

- L0_業務_小規模多機能とは.md（登録定員29人、泊まり定員9人の根拠）
- L1_技術_実装制約.md（日付文字列、localStorage）

---

## 📅 更新履歴

| 日付 | バージョン | 変更内容 | 担当 |
|------|----------|---------|------|
| 2025-11-23 | 1.0 | 初版作成 | Claude |

---

**最終更新**: 2025年11月23日  
**次回更新予定**: Phase 1実装中のフィードバック反映時

---

## ⚠️ 設計チェックリスト

このドキュメントの品質チェック：

- [x] すべてのプロパティの型が明記されている
- [x] Date型と文字列の使い分けが明確
- [x] 型変換の責任が明確（どこで変換するか）
- [x] null/undefinedの扱いが定義されている
- [x] バリデーションルールが網羅されている
- [x] Phase 1とPhase 2の実装範囲が明確
- [x] データの永続化方法が具体的
- [x] 参照方法とアクセスパターンが明確

---

**このドキュメントを読了したら、INDEX_ドキュメント構成.md に戻り、次のドキュメントに進んでください。**
